I"ôp<h2 id="introduction">Introduction</h2>
<p>This API is asynchronous at its very core. We use Vert.x which is a toolkit, built on top of Netty. It is heavily inspired by Node.js but for the JVM. As such it uses event loop(s), that is thread(s), which never should by blocked by long running CPU tasks or disk bound I/O. We are using Kotlin with coroutines to keep the code simple.
Authorization is done via OAuth2 (Password Credentials/Resource Owner Flow) using a Keycloak authorization server instance. Keycloak can be set up as described in this excellent <a href="https://piotrminkowski.wordpress.com/2017/09/15/building-secure-apis-with-vert-x-and-oauth2/">tutorial</a>.
All you have to change is setting the client-id to ‚Äúsirix‚Äù and put the client secret into our <a href="https://raw.githubusercontent.com/sirixdb/sirix/master/bundles/sirix-rest-api/src/main/resources/sirix-conf.json">configuration file</a>. Change the value of ‚Äúclient.secret‚Äù to whatever Keycloak set up (can be found on the credentials tab of your account). Regarding Keycloak the direct access grant on the settings tab must be enabled. Our user-roles are ‚Äúcreate‚Äù to allow creating databases/resources, ‚Äúview‚Äù to allow to query database resources, ‚Äúmodify‚Äù to modify a database resource and ‚Äúdelete‚Äù to allow deletion thereof. Furthermore, a <code class="highlighter-rouge">key.pem</code> and a <code class="highlighter-rouge">cert.pem</code> file are needed. These two files have to be in your user home directory in a directory called ‚Äúsirix-data‚Äù, where Sirix stores the databases. For demo purposes they can be copied from our <a href="https://github.com/sirixdb/sirix/tree/master/bundles/sirix-rest-api/src/main/resources">resources directory</a>.</p>

<p>To created a fat-JAR. Download our ZIP-file for instance, then</p>

<ol>
  <li><code class="highlighter-rouge">cd bundles/sirix-rest-api</code></li>
  <li><code class="highlighter-rouge">mvn clean package -DskipTests</code></li>
</ol>

<p>And a fat-JAR with all required dependencies should have been created in your target folder.</p>

<p>Once also Keycloak is set up we can start the server via:</p>

<p><code class="highlighter-rouge">java -jar -Duser.home=/opt/sirix sirix-rest-api-*-SNAPSHOT-fat.jar -conf sirix-conf.json -cp /opt/sirix/*</code></p>

<p>If you like to change your user home directory to <code class="highlighter-rouge">/opt/sirix</code> for instance.</p>

<p>The fat-JAR in the future will be downloadable from the <a href="https://oss.sonatype.org/content/repositories/snapshots/io/sirix/sirix-rest-api/0.9.0-SNAPSHOT/">maven repository</a>.</p>

<p>After Keycloak and our server are up and running, we can write a simple HTTP-Client. We first have to obtain a token from the <code class="highlighter-rouge">/login</code> endpoint with a given ‚Äúusername/password‚Äù JSON-Object. Using an asynchronous HTTP-Client (from Vert.x) in Kotlin, it looks like this:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">server</span> <span class="p">=</span> <span class="s">"https://localhost:9443"</span>

<span class="kd">val</span> <span class="py">credentials</span> <span class="p">=</span> <span class="nf">json</span> <span class="p">{</span>
  <span class="nf">obj</span><span class="p">(</span><span class="s">"username"</span> <span class="n">to</span> <span class="s">"testUser"</span><span class="p">,</span>
      <span class="s">"password"</span> <span class="n">to</span> <span class="s">"testPass"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">val</span> <span class="py">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">postAbs</span><span class="p">(</span><span class="s">"$server/login"</span><span class="p">).</span><span class="nf">sendJsonAwait</span><span class="p">(</span><span class="n">credentials</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="m">200</span> <span class="p">==</span> <span class="n">response</span><span class="p">.</span><span class="nf">statusCode</span><span class="p">())</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">bodyAsJsonObject</span><span class="p">()</span>
  <span class="kd">val</span> <span class="py">accessToken</span> <span class="p">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">getString</span><span class="p">(</span><span class="s">"access_token"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This access token must then be sent in the Authorization HTTP-Header for each subsequent request. Storing a first resource would look like (simple HTTP PUT-Request):</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">xml</span> <span class="p">=</span> <span class="s">"""
    &lt;xml&gt;
      foo
      &lt;bar/&gt;
    &lt;/xml&gt;
"""</span><span class="p">.</span><span class="nf">trimIndent</span><span class="p">()</span>

<span class="kd">var</span> <span class="py">httpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">putAbs</span><span class="p">(</span><span class="s">"$server/database/resource1"</span><span class="p">).</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">AUTHORIZATION</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"Bearer $accessToken"</span><span class="p">).</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">CONTENT_TYPE</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">).</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ACCEPT</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">).</span><span class="nf">sendBufferAwait</span><span class="p">(</span><span class="nc">Buffer</span><span class="p">.</span><span class="nf">buffer</span><span class="p">(</span><span class="n">xml</span><span class="p">))</span>
  
<span class="k">if</span> <span class="p">(</span><span class="m">200</span> <span class="p">==</span> <span class="n">response</span><span class="p">.</span><span class="nf">statusCode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nf">println</span><span class="p">(</span><span class="s">"Stored document."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">println</span><span class="p">(</span><span class="s">"Something went wrong ${response.message}"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>First, an empty database with the name <code class="highlighter-rouge">database</code> with some metadata is created, second the XML-fragment is stored with the name <code class="highlighter-rouge">resource1</code>. The PUT HTTP-Request is idempotent. Another PUT-Request with the same URL endpoint will delete the former database and resource and create the database and resource again. Note that every request has to contain an <code class="highlighter-rouge">HTTP-Header</code> which content type it sends and which resource-type it expects (<code class="highlighter-rouge">Content-Type: application/xml</code> and <code class="highlighter-rouge">Accept: application/xml</code>) for instance. This is needed as SirixDB supports the storage and retrieval of both XML- and JSON-data. Furthermore in case of updates as described in <a href="http://nbn-resolving.de/urn:nbn:de:bsz:352-opus-123507">Integrity Assurance for RESTful XML</a> you have to make sure to include the hashCode of the node you want to modify in the ‚ÄúETag‚Äù HTTP-Header. For instance if you want to insert a subtree as the first child of a node, the hashCode of the ‚Äúparent‚Äù node must be in the HTTP-Header. The following sections show the API for usage with our binary and in-memory XML representation, but the JSON version is almost analogous.</p>

<p>The HTTP-Response should be 200 and the HTTP-body yields:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rest:sequence</span> <span class="na">xmlns:rest=</span><span class="s">"https://sirix.io/rest"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;rest:item&gt;</span>
    <span class="nt">&lt;xml</span> <span class="na">rest:id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
      foo
      <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/xml&gt;</span>
  <span class="nt">&lt;/rest:item&gt;</span>
<span class="nt">&lt;/rest:sequence&gt;</span>
</code></pre></div></div>

<p>We are serializing the generated IDs from our storage system for element-nodes.</p>

<p>Via a <code class="highlighter-rouge">GET HTTP-Request</code> to <code class="highlighter-rouge">https://localhost:9443/database/resource1</code> we are also able to retrieve the stored resource again.</p>

<p>However, this is not really interesting so far. We can update the resource via a <code class="highlighter-rouge">POST-Request</code>. Assuming we retrieved the access token as before, we can simply do a POST-Request and use the information we gathered before about the node-IDs:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// First get the hashCode of the node with ID 3.</span>
<span class="kd">var</span> <span class="py">httpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">headAbs</span><span class="p">(</span><span class="s">"$server/database/resource1?nodeId=3"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">AUTHORIZATION</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"Bearer $accessToken"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">CONTENT_TYPE</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ACCEPT</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">sendAWait</span><span class="p">()</span>

<span class="kd">val</span> <span class="py">hashCode</span> <span class="p">=</span> <span class="n">httpResponse</span><span class="p">.</span><span class="nf">getHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ETAG</span><span class="p">.</span><span class="nf">toString</span><span class="p">())</span>

<span class="kd">val</span> <span class="py">xml</span> <span class="p">=</span> <span class="s">"""
    &lt;test&gt;
      yikes
      &lt;bar/&gt;
    &lt;/test&gt;
"""</span><span class="p">.</span><span class="nf">trimIndent</span><span class="p">()</span>

<span class="kd">val</span> <span class="py">url</span> <span class="p">=</span> <span class="s">"$server/database/resource1?nodeId=3&amp;insert=asFirstChild"</span>

<span class="n">httpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">postAbs</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">AUTHORIZATION</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"Bearer $accessToken"</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">CONTENT_TYPE</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ACCEPT</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ETAG</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="n">hashCode</span><span class="p">)</span>
                     <span class="p">.</span><span class="nf">sendBufferAwait</span><span class="p">(</span><span class="nc">Buffer</span><span class="p">.</span><span class="nf">buffer</span><span class="p">(</span><span class="n">xml</span><span class="p">))</span>
</code></pre></div></div>

<p>The interesting part is the URL, we are using as the endpoint. We simply say, select the node with the ID 3, then insert the given XML-fragment as the first child. This yields the following serialized XML-document:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rest:sequence</span> <span class="na">xmlns:rest=</span><span class="s">"https://sirix.io/rest"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;rest:item&gt;</span>
    <span class="nt">&lt;xml</span> <span class="na">rest:id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
      foo
      <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"3"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;test</span> <span class="na">rest:id=</span><span class="s">"4"</span><span class="nt">&gt;</span>
          yikes
          <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"6"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/test&gt;</span>
      <span class="nt">&lt;/bar&gt;</span>
    <span class="nt">&lt;/xml&gt;</span>
  <span class="nt">&lt;/rest:item&gt;</span>
<span class="nt">&lt;/rest:sequence&gt;</span>
</code></pre></div></div>
<p>The interesting part is that every PUT- as well as POST-request does an implicit <code class="highlighter-rouge">commit</code> of the underlying transaction. Thus, we are now able send the first GET-request for retrieving the contents of the whole resource again for instance through specifying an simple XPath-query, to select the root-node in all revisions <code class="highlighter-rouge">GET https://localhost:9443/database/resource1?query=/xml/all-time::*</code> and get the following XPath-result:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rest:sequence</span> <span class="na">xmlns:rest=</span><span class="s">"https://sirix.io/rest"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;rest:item</span> <span class="na">rest:revision=</span><span class="s">"1"</span> <span class="na">rest:revisionTimestamp=</span><span class="s">"2018-12-20T18:44:39.464Z"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;xml</span> <span class="na">rest:id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
      foo
      <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/xml&gt;</span>
  <span class="nt">&lt;/rest:item&gt;</span>
  <span class="nt">&lt;rest:item</span> <span class="na">rest:revision=</span><span class="s">"2"</span> <span class="na">rest:revisionTimestamp=</span><span class="s">"2018-12-20T18:44:39.518Z"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;xml</span> <span class="na">rest:id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
      foo
      <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"3"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;xml</span> <span class="na">rest:id=</span><span class="s">"4"</span><span class="nt">&gt;</span>
          foo
          <span class="nt">&lt;bar</span> <span class="na">rest:id=</span><span class="s">"6"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/xml&gt;</span>
      <span class="nt">&lt;/bar&gt;</span>
    <span class="nt">&lt;/xml&gt;</span>
  <span class="nt">&lt;/rest:item&gt;</span>
<span class="nt">&lt;/rest:sequence&gt;</span>
</code></pre></div></div>

<p>In general we support several additional temporal XPath axis:</p>

<p><code class="highlighter-rouge">future::</code>, <code class="highlighter-rouge">future-or-self::</code>, <code class="highlighter-rouge">past::</code>,<code class="highlighter-rouge">past-or-self::</code>,<code class="highlighter-rouge">previous::</code>,<code class="highlighter-rouge">previous-or-self::</code>,<code class="highlighter-rouge">next::</code>,<code class="highlighter-rouge">next-or-self::</code>,<code class="highlighter-rouge">first::</code>,<code class="highlighter-rouge">last::</code>,<code class="highlighter-rouge">all-time::</code></p>

<p>The same can be achieved through specifying a range of revisions to serialize (start- and end-revision parameters) in the GET-request:</p>

<p><code class="highlighter-rouge">GET https://localhost:9443/database/resource1?start-revision=1&amp;end-revision=2</code></p>

<p>or via timestamps:</p>

<p><code class="highlighter-rouge">GET https://localhost:9443/database/resource1?start-revision-timestamp=2018-12-20T18:00:00&amp;end-revision-timestamp=2018-12-20T19:00:00</code></p>

<p>We for sure are also able to delete the resource or any subtree thereof by an updating XQuery expression (which is not very RESTful) or with a simple <code class="highlighter-rouge">DELETE</code> HTTP-request:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// First get the hashCode of the node with ID 3.</span>
<span class="kd">var</span> <span class="py">httpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">headAbs</span><span class="p">(</span><span class="s">"$server/database/resource1?nodeId=3"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">AUTHORIZATION</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"Bearer $accessToken"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">CONTENT_TYPE</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ACCEPT</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">sendAWait</span><span class="p">()</span>

<span class="kd">val</span> <span class="py">hashCode</span> <span class="p">=</span> <span class="n">httpResponse</span><span class="p">.</span><span class="nf">getHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ETAG</span><span class="p">.</span><span class="nf">toString</span><span class="p">())</span>

<span class="kd">val</span> <span class="py">url</span> <span class="p">=</span> <span class="s">"$server/database/resource1?nodeId=3"</span>

<span class="kd">val</span> <span class="py">httpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">deleteAbs</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">AUTHORIZATION</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"Bearer $accessToken"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ACCEPT</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="s">"application/xml"</span><span class="p">)</span>
                         <span class="p">.</span><span class="nf">putHeader</span><span class="p">(</span><span class="nc">HttpHeaders</span><span class="p">.</span><span class="nc">ETAG</span><span class="p">.</span><span class="nf">toString</span><span class="p">(),</span> <span class="n">hashCode</span><span class="p">).</span><span class="nf">sendAwait</span><span class="p">()</span>

<span class="k">if</span> <span class="p">(</span><span class="m">200</span> <span class="p">==</span> <span class="n">httpResponse</span><span class="p">.</span><span class="nf">statusCode</span><span class="p">())</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This deletes the node with ID 3 and in our case as it‚Äôs an element node the whole subtree. For sure it‚Äôs committed as revision 3 and as such all old revisions still can be queried for the whole subtree (or in the first revision it‚Äôs only the element with the name ‚Äúbar‚Äù without any subtree).</p>

<p>If we want to get a diff, currently in the form of an XQuery Update Statement (but we could serialize them in any format), simply call the XQuery function <code class="highlighter-rouge">sdb:diff</code>:</p>

<p><code class="highlighter-rouge">sdb:diff($coll as xs:string, $res as xs:string, $rev1 as xs:int, $rev2 as xs:int) as xs:string</code></p>

<p>For instance via a GET-request like this for the database/resource we created above, we could make this request:</p>

<p><code class="highlighter-rouge">GET https://localhost:9443/?query=sdb%3Adiff%28%27database%27%2C%27resource1%27%2C1%2C2%29</code></p>

<p>Note that the query-String has to be URL-encoded, thus it‚Äôs decoded</p>

<p><code class="highlighter-rouge">sdb:diff('database','resource1',1,2)</code></p>

<p>The output for the diff in our example is this XQuery-Update statement wrapped in an enclosing sequence-element:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;rest:sequence</span> <span class="na">xmlns:rest=</span><span class="s">"https://sirix.io/rest"</span><span class="nt">&gt;</span>
  let $doc := sdb:doc('database','resource1', 1)
  return (
    insert nodes <span class="nt">&lt;xml&gt;</span>foo<span class="nt">&lt;bar/&gt;&lt;/xml&gt;</span> as first into sdb:select-node($doc, 3)
  )
<span class="nt">&lt;/rest:sequence&gt;</span>
</code></pre></div></div>

<p>This means the <code class="highlighter-rouge">resource1</code> from <code class="highlighter-rouge">database</code> is opened in the first revision. Then the subtree <code class="highlighter-rouge">&lt;xml&gt;foo&lt;bar/&gt;&lt;/xml&gt;</code> is appended to the node with the stable node-ID 3 as a first child.</p>

<p>The following sections give a complete specification of the routes:</p>

<p><code class="highlighter-rouge">PUT https://localhost:9443/database/resource</code> creates a database and a resource (content being the body of the request ‚Äì as of now XML, but we‚Äôll implement JSON resources in the very near future).</p>

<p><code class="highlighter-rouge">GET https://localhost:9443/database/resource</code> simply serializes the internal binary tree representation back to XML. Optional URL-parameters are</p>

<ul>
  <li><code class="highlighter-rouge">revision</code>  or <code class="highlighter-rouge">revision-timestamp</code> (the former being a simple long number, the latter being an ISO formatted datetime string as the parameter, for instance <code class="highlighter-rouge">2019-01-01T05:05:01</code>), to open a specific revision. In case of the <code class="highlighter-rouge">revision-timestamp</code>parameter either the exact revision is going to be selected via binary search, or the closest revision to the given point in time.</li>
  <li><code class="highlighter-rouge">start-revision</code> and <code class="highlighter-rouge">end-revision</code> or <code class="highlighter-rouge">start-revision-timestamp</code> and <code class="highlighter-rouge">end-revision-timestamp</code> for a specific timespan.</li>
  <li>Furthermore a <code class="highlighter-rouge">nodeId</code>-parameter can be specified to retrieve a specific node in a revision.</li>
  <li>The <code class="highlighter-rouge">query</code>-parameter can be used to specify a full blown XQuery-string. Here for instance also temporal axis can be used to analyze how a specific node or subtree changed over time or to display which nodes are new in a specific revision. There‚Äôs also a <code class="highlighter-rouge">diff</code>-function which outputs an XQuery Update script to update the first revision to the second. Other formats as output to another diff-function are for sure have to be evaluated.</li>
</ul>

<p>Omitting the resource in the URL (<code class="highlighter-rouge">GET https://localhost:9443/database</code>) lists all resources of the database. <code class="highlighter-rouge">GET https://localhost:9443/</code> lists all databases.</p>

<p><code class="highlighter-rouge">POST https://localhost:9443/database/resource</code> for adding content from the request-body. Supported URL-parameters are</p>
<ul>
  <li><code class="highlighter-rouge">nodeId</code>, to select the context-Node.</li>
  <li><code class="highlighter-rouge">insert</code> with the possible values, <code class="highlighter-rouge">asFirstChild</code>, <code class="highlighter-rouge">asLeftSibling</code>, <code class="highlighter-rouge">asRightSibling</code>, <code class="highlighter-rouge">replace</code>, to determine where to insert the XML-fragment.</li>
</ul>

<p>If both parameters are omitted the root-node (and its subtree) is going to be replaced by the new XML fragment. As such an error is thrown if the HTTP request body doesn‚Äôt start with a start-tag.</p>

<p>Using a POST HTTP-request to <code class="highlighter-rouge">https://localhost:9443</code> can be used to send a longer XQuery-expression in the body.</p>

<p><code class="highlighter-rouge">DELETE https://localhost:9443/database/resource</code> removes the resource from the database. Omitting the resource in the URL, the whole database is going to be deleted. The optional parameter once again is <code class="highlighter-rouge">nodeId</code> to remove a node or in case the nodeId references an element node to remove the whole subtree and the element node itself.</p>
:ET