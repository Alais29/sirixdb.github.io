I"cP<h2 id="maven-artifacts">Maven artifacts</h2>

<p>First, you have to get the dependency on our SirixDB core project. At this stage of development please use the latest SNAPSHOT artifacts from the OSS snapshot repository. Just add the following repository section to your POM file:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;repository&gt;</span>
  <span class="nt">&lt;id&gt;</span>sonatype-nexus-snapshots<span class="nt">&lt;/id&gt;</span>
  <span class="nt">&lt;name&gt;</span>Sonatype Nexus Snapshots<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;url&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="nt">&lt;/url&gt;</span>
  <span class="nt">&lt;releases&gt;</span>
    <span class="nt">&lt;enabled&gt;</span>false<span class="nt">&lt;/enabled&gt;</span>
  <span class="nt">&lt;/releases&gt;</span>
  <span class="nt">&lt;snapshots&gt;</span>
    <span class="nt">&lt;enabled&gt;</span>true<span class="nt">&lt;/enabled&gt;</span>
  <span class="nt">&lt;/snapshots&gt;</span>
<span class="nt">&lt;/repository&gt;</span>
</code></pre></div></div>

<p>Or for Gradle:</p>
<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'java'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'maven'</span>

<span class="k">repositories</span> <span class="o">{</span>
    <span class="n">maven</span> <span class="o">{</span>
          <span class="n">url</span> <span class="s2">"https://oss.sonatype.org/content/repositories/snapshot"</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, if you prefer, we just released version 0.9.3 of SirixDB in Maven Central. Currently, the following SNAPSHOT-artifacts are available. Make sure that snapshots are getting updated with newer versions in your IDE.</p>

<p>Core project:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.sirix<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>sirix-core<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>0.9.4-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>To add the dependency in Gradle:</p>
<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">dependencies</span> <span class="o">{</span>
  <span class="n">compile</span> <span class="s1">'io.sirix:sirix-core:0.9.4-SNAPSHOT'</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="tree-encoding-in-sirixdb">Tree-Encoding in SirixDB</h2>
<p>The encoding of the underlying tree structure of both XML and JSON documents in SirixDB uses a pointer-based approach.</p>

<p>SirixDB doesn’t use range-encodings (not update-friendly) or hierarchical labels (B+-tree index-structure traversal might be too expensive). However, we can specify that SirixDB stores hierarchical labels (DeweyIDs) for XML-resources to provide fast document order determination.</p>

<p>Instead of the aforementioned encodings, a node in SirixDB references other nodes by a firstChild/leftSibling/rightSibling/parentNodeKey/nodeKey encoding. Think of it as a persistent DOM:</p>

<div class="img_container">
  <p><img src="images/encoding.png" alt="encoding" /></p>
</div>

<p>The numbers in the figure are auto-generated unique, stable node-IDs or node-keys generated with a simple sequential number generator.</p>

<p>Every structural node might have a first child, a left sibling, a right sibling, and a parent node.</p>

<p>Namespaces and attributes are the only non-structural nodes in XML resources. They have a parent pointer. If the transactional cursor points to an element node, you can reference these nodes through special moveToAttribute and moveToNamespace.</p>

<p>In the JSON-to-tree mapping, however, every node is a structural node. To support fine granular versioning of nodes and to be able to reuse the axis-implementations, SirixDB uses the same encoding for JSON resources as we’ve seen.</p>

<p>Thus we’ll introduce a unique API, which we’re going to use for both traversing and updating XML and JSON resource with only subtle differences.</p>

<p><strong>Note that the binary JSON-format in SirixDB allows ordered, duplicate object record keys. Upper layers, however, may store object records in a hash map, thus not keeping track of the order nor supporting duplicate record keys.</strong></p>

<h2 id="create-a-database-with-a-single-resource">Create a Database With a Single Resource</h2>

<h3 id="create-an-xml-database-and-resource">Create an XML Database and Resource</h3>
<p>First, we want to show how to create a database with a single resource:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// XML-file to import.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">pathToXmlFile</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"xmlFile"</span><span class="o">);</span>

<span class="c1">// Path to create the database at.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">databaseFile</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"database"</span><span class="o">);</span>

<span class="c1">// Create a new lightweight database structure.</span>
<span class="nc">Databases</span><span class="o">.</span><span class="na">createXmlDatabase</span><span class="o">(</span><span class="k">new</span> <span class="nc">DatabaseConfiguration</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">));</span>

<span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openXmlDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// Create a first resource without text-value compression but with DeweyIDs which are</span>
  <span class="c1">// hierarchical node labels.</span>
  <span class="n">database</span><span class="o">.</span><span class="na">createResource</span><span class="o">(</span>
    <span class="nc">ResourceConfiguration</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">"resource"</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">useTextCompression</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">useDeweyIDs</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">versioningApproach</span><span class="o">(</span><span class="nc">VersioningType</span><span class="o">.</span><span class="na">DIFFERENTIAL</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">revisionsToRestore</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">buildPathSummary</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">build</span><span class="o">());</span>

  <span class="k">try</span> <span class="o">(</span><span class="c1">// Open a resource manager.</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
       <span class="c1">// Open only write transaction on the resource (transaction provides</span>
       <span class="c1">// a cursor for navigation through moveToX-methods).</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">wtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">();</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">pathToXmlFile</span><span class="o">.</span><span class="na">toFile</span><span class="o">()))</span> <span class="o">{</span>
       
       <span class="c1">// Import an XML document.</span>
       <span class="n">wtx</span><span class="o">.</span><span class="na">insertSubtreeAsFirstChild</span><span class="o">(</span><span class="nc">XmlShredder</span><span class="o">.</span><span class="na">createFileReader</span><span class="o">(</span><span class="n">fis</span><span class="o">));</span>

       <span class="c1">// Commit and persist the changes.</span>
       <span class="n">wtx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The resource is built with text node-compression disabled and so-called DeweyIDs enabled. DeweyIDs are a form of hierarchical node labels for instance used by an XQuery processor to quickly determine document-order (which node comes first during a preorder traversal).</p>

<p>In the above example, we show how you can specify a versioning approach that SirixDB is going to use to version data-pages. Default is the sliding snapshot algorithm, which is the best option in most cases. However, we want to demonstrate the most commonly used builder options.</p>

<p>The <code class="highlighter-rouge">revisionsToRestore</code>-method is used in conjunction with the versioning approach. When you specify the differential or incremental versioning approach it denotes after how many revisions SirixDB serializes a new full-page snapshot. In case you specify the sliding snapshot, it is the windows-size. It has no effect when you use full-versioning.</p>

<p>The method <code class="highlighter-rouge">buildPathSummary</code> specifies if SirixDB should build and automatically keep a summary of all paths up-to-date. We omit other builder options here for brevity as defining a byte handler pipeline, which is used to serialize/deserialize page-fragments.</p>

<h3 id="create-a-json-database-and-resource">Create a JSON Database and Resource</h3>

<p>In order to import a single JSON file you can almost use the same API:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JSON-file to import.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">pathToJsonFile</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"jsonFile"</span><span class="o">);</span>

<span class="c1">// Create database configuration.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">databaseFile</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"database"</span><span class="o">);</span>

<span class="c1">// Create a new lightweight database structure.</span>
<span class="nc">Databases</span><span class="o">.</span><span class="na">createJsonDatabase</span><span class="o">(</span><span class="k">new</span> <span class="nc">DatabaseConfiguration</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">));</span>

<span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openJsonDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// Create a first resource with all standard builder settings set.</span>
  <span class="n">database</span><span class="o">.</span><span class="na">createResource</span><span class="o">(</span><span class="nc">ResourceConfiguration</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="s">"resource"</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>

  <span class="k">try</span> <span class="o">(</span><span class="c1">// Open a resource manager.</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
       <span class="c1">// Open only write transaction on the resource (transaction provides</span>
       <span class="c1">// a cursor for navigation through moveToX-methods).</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">wtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">();</span>
       <span class="kd">final</span> <span class="kt">var</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">pathToJsonFile</span><span class="o">.</span><span class="na">toFile</span><span class="o">()))</span> <span class="o">{</span>
       
       <span class="c1">// Import a JSON-document.</span>
       <span class="n">wtx</span><span class="o">.</span><span class="na">insertSubtreeAsFirstChild</span><span class="o">(</span><span class="nc">JsonShredder</span><span class="o">.</span><span class="na">createFileReader</span><span class="o">(</span><span class="n">fis</span><span class="o">));</span>

       <span class="c1">// Commit and persist the changes.</span>
       <span class="n">wtx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h2 id="open-a-resource-in-a-database-and-iterate">Open a Resource in a Database and Iterate</h2>

<h3 id="preorder-navigation-in-an-xml-resource">Preorder Navigation in an XML resource</h3>

<p>Now, that you’ve have imported the first resource into SirixDB, you can reuse the read-write transaction after issuing the commit. Alternatively, you can open the resource manager again and start a new read-only transaction.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openXmlDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
     <span class="c1">// Now open a read-only transaction again.</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">rtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeReadOnlyTrx</span><span class="o">())</span> <span class="o">{</span>
    
  <span class="c1">// Use the descendant axis to iterate over all structural descendant nodes</span>
  <span class="c1">// (each node with the exception of namespace- and attribute-nodes) in</span>
  <span class="c1">// pre-order (depth-first).</span>
  <span class="k">new</span> <span class="nf">DescendantAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="nc">IncludeSelf</span><span class="o">.</span><span class="na">YES</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="n">unused</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// The transaction-cursor is moved to each structural node</span>
    <span class="c1">// (all nodes, except for namespace- and attributes in preorder).</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getKind</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nl">ELEMENT:</span>
        <span class="c1">// In order to process namespace-nodes we could do the following and</span>
        <span class="c1">// log the full qualified name of each node.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nspCount</span> <span class="o">=</span> <span class="n">rtx</span><span class="o">.</span><span class="na">getNamespaceCount</span><span class="o">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nspCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">rtx</span><span class="o">.</span><span class="na">moveToNamespace</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
          <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
          <span class="n">rtx</span><span class="o">.</span><span class="na">moveToParent</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// In order to process attribute-nodes we could do the following and</span>
        <span class="c1">// log the full qualified name of each node. </span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">attrCount</span> <span class="o">=</span> <span class="n">rtx</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attrCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">rtx</span><span class="o">.</span><span class="na">moveToAttribute</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
          <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Attribute name:"</span> <span class="o">+</span> <span class="n">rtx</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
          <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Attribute value:"</span> <span class="o">+</span> <span class="n">rtx</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
          <span class="n">rtx</span><span class="o">.</span><span class="na">moveToParent</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">break</span><span class="o">;</span>
        
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getDescendantCount</span><span class="o">());</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getChildCount</span><span class="o">());</span>
        <span class="cm">/* 
         * Hash of a node, build bottom up for all nodes (depends on descendant
         * hashes, however only ancestor nodes are updated during a normal
         * edit-operation. During bulk inserts with insertSubtree(...) the hashes
         * are generated during a postorder-traversal, just like the
         * descendant-count of each structural node.
         */</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getHash</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">COMMENT:</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">TEXT:</span>
        <span class="c1">// Log the text-value.</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="c1">// Other node types omitted.</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="c1">// Do nothing.</span>
    <span class="o">};</span>
  <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You can use the descendant axis to iterate over all structural descendant nodes in preorder (depth-first). Recall that structural nodes are all nodes except for namespaces and attributes. Hashes of nodes are built bottom-up for all nodes per default depending on the resource configuration. Only ancestor nodes are updated during a single edit-operation.</p>

<p>During bulk insertions with one of the insertSubtree-methods, the hashes are generated during a postorder-traversal, just like the descendant-count of each structural node. They’re created after the nodes have been added to a transaction-intent log. The log is an in-memory buffer of writes, backed by a persistent append-only file. It is written to the data file preferably on a flash drive during a commit.</p>

<h3 id="preorder-navigation-in-a-json-resource">Preorder Navigation in a JSON resource</h3>

<p>JSON obviously has no namespaces or attributes, but with this exception, you can use the axis in the same way:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openJsonDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
     <span class="c1">// Now open a read-only transaction again on the most recent revision.</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">rtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeReadOnlyTrx</span><span class="o">())</span> <span class="o">{</span>
    
  <span class="c1">// Use the descendant axis to iterate over all descendant nodes in pre-order</span>
  <span class="c1">// (depth-first).</span>
  <span class="k">new</span> <span class="nf">DescendantAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="nc">IncludeSelf</span><span class="o">.</span><span class="na">YES</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="n">unused</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// The transaction-cursor is moved to each structural node</span>
    <span class="c1">// (all nodes, except for namespace- and attributes in preorder).</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getKind</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nl">OBJECT_KEY:</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">STRING_VALUE:</span>
      <span class="k">case</span> <span class="nl">BOOLEAN_VALUE:</span>
      <span class="k">case</span> <span class="nl">NUMBER_VALUE:</span>
      <span class="k">case</span> <span class="nl">NULL_VALUE:</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="c1">// ARRAY- and OBJECT-nodes omitted.</span>
    <span class="o">}</span>
  <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="axes-to-navigate-in-space-and-time">Axes to Navigate in Space and Time</h2>
<p>SirixDB provides several axes to navigate through the tree structures of both the binary XML as well as the JSON encoding. Namely all of the axes known from XPath plus a few more.</p>

<h3 id="non-structural-wrapper-axis-for-xml-resources">Non Structural Wrapper Axis for XML resources</h3>

<p>As it’s a common task to iterate over structural and non-structural nodes, that is namespaces and especially attributes, SirixDB provides a simple wrapper axis:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">NonStructuralWrapperAxis</span><span class="o">(</span><span class="k">new</span> <span class="nc">DescendantAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">))</span>
</code></pre></div></div>

<p>This axis as its sole argument needs another axis to iterate through structural nodes (all nodes with the exception of attributes and namespaces). Every time the cursor is located on an element-node the axis checks for namespace- as well as attribute-nodes and iterates over them before using the delegate axis to move to the next structural node. Note that SirixDB also offers a
<code class="highlighter-rouge">NamespaceAxis</code> and an <code class="highlighter-rouge">AttributeAxis</code>.</p>

<h3 id="visitor-descendant-axis">Visitor Descendant Axis</h3>

<p>As it’s very common to define behavior based on the different node-types we’re able to use the visitor pattern. We can specify a
visitor as a builder argument for a special preorder-axis called <code class="highlighter-rouge">VisitorDescendantAxis</code>. It uses the return types from the visit-methods a visitor has to implement to guide the traversal. For each type of node, there’s an equivalent visit-method. For instance, for element nodes it is the <code class="highlighter-rouge">VisitResult visit(ImmutableElement node)</code>.</p>

<p>Another visitor-interface exists for JSON nodes (only difference are the node-type parameters). Thus we’re able to use the same axis to traverse both XML as well as JSON resources.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Do something when visiting a {@link ImmutableElement}.
 * 
 * @param node the {@link ImmutableElement}
 */</span>
<span class="nc">VisitResult</span> <span class="nf">visit</span><span class="o">(</span><span class="nc">ImmutableElement</span> <span class="n">node</span><span class="o">);</span>
</code></pre></div></div>
<p>Another visitor exists for JSON-resources.</p>

<p>The only implementation of the <code class="highlighter-rouge">VisitResult</code> interface is the following enum:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * The result type of an {@link XdmNodeVisitor} implementation.
 * 
 * @author Johannes Lichtenberger, University of Konstanz
 */</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="nc">VisitResultType</span> <span class="kd">implements</span> <span class="nc">VisitResult</span> <span class="o">{</span>
  <span class="cm">/** Continue without visiting the siblings of this node. */</span>
  <span class="no">SKIPSIBLINGS</span><span class="o">,</span>

  <span class="cm">/** Continue without visiting the descendants of this node. */</span>
  <span class="no">SKIPSUBTREE</span><span class="o">,</span>

  <span class="cm">/** Continue traversal. */</span>
  <span class="no">CONTINUE</span><span class="o">,</span>

  <span class="cm">/** Terminate traversal. */</span>
  <span class="no">TERMINATE</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">VisitorDescendantAxis</code> iterates through the tree structure in preorder. It uses the <code class="highlighter-rouge">VisitResultType</code>s to guide the
traversal. <code class="highlighter-rouge">SKIPSIBLINGS</code> means, that the traversal should continue without visiting the right siblings of the current node the
cursor points to. <code class="highlighter-rouge">SKIPSUBTREE</code> means to continue without visiting the descendants of this node. You can use <code class="highlighter-rouge">CONTINUE</code> if traversal should continue in preorder. You can use <code class="highlighter-rouge">TERMINATE</code> to terminate the traversal immediately.</p>

<p>The default implementation of each method in the <code class="highlighter-rouge">Visitor</code>-interface returns <code class="highlighter-rouge">VisitResultType.CONTINUE</code> for each node-type. Thus, you only have to implement the methods (for the nodes), which you’re interested in. If you’ve implemented a class called <code class="highlighter-rouge">MyVisitor</code> you can use the <code class="highlighter-rouge">VisitorDescendantAxis</code> in the following way:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Executes a modification visitor for each descendant node.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="nc">VisitorDescendantAxis</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">rtx</span><span class="o">)</span>
                                      <span class="o">.</span><span class="na">includeSelf</span><span class="o">()</span>
                                      <span class="o">.</span><span class="na">visitor</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyVisitor</span><span class="o">())</span>
                                      <span class="o">.</span><span class="na">build</span><span class="o">();</span>
     
<span class="k">while</span> <span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="n">axis</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</code></pre></div></div>

<p>The methods in <code class="highlighter-rouge">MyVisitor</code> are called for each node in the traversal. The traversal begins with the node the cursor currently
points to.</p>

<h3 id="additional-axes">Additional Axes</h3>

<p>SirixDB provides all possible XPath axes for both traversing XML as well as JSON resources. Note, that the <code class="highlighter-rouge">PrecedingAxis</code> and the <code class="highlighter-rouge">PrecedingSiblingAxis</code> don’t deliver nodes in document order (preorder), but in the natural encountered order. Furthermore, a <code class="highlighter-rouge">PostOrderAxis</code> is available, which traverses the tree in a postorder traversal. Similarly, a <code class="highlighter-rouge">LevelOrderAxis</code> traverses the tree in a breadth-first manner. SirixDB also provides a <code class="highlighter-rouge">ConcurrentAxis</code>, a <code class="highlighter-rouge">ConcurrentUnionAxis</code>, a <code class="highlighter-rouge">ConcurrentIntersectAxis</code> and a <code class="highlighter-rouge">ConcurrentExceptAxis</code> to prefetch nodes concurrently and in parallel.</p>

<h3 id="filtering-for-specific-nodes">Filtering for Specific Nodes</h3>

<p>SirixDB provides several filters, which you can plug in through a <code class="highlighter-rouge">FilterAxis</code>. The following code, for instance, traverses all children of an element node (provided that the transaction currently points to an element node) and filters for nodes with the local name “a” in an XML resource.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;</span><span class="nc">XdmNodeReadOnlyTrx</span><span class="o">&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">XmlNameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"a"</span><span class="o">))</span>
</code></pre></div></div>

<p>Regarding JSON resources it’s as simple as changing the generics argument from <code class="highlighter-rouge">XdmNodeReadOnlyTrx</code> to <code class="highlighter-rouge">JsonNodeReadOnlyTrx</code> to change the transaction argument type as well as changing the <code class="highlighter-rouge">XmlNameFilter</code> to <code class="highlighter-rouge">JsonNameFilter</code>.</p>

<p>The following code traverses all children of an object node and filters for object key nodes with the key “a” as in <code class="highlighter-rouge">{"a":1, "b": "foo"}</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;</span><span class="nc">JsonNodeReadOnlyTrx</span><span class="o">&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">JsonNameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"a"</span><span class="o">))</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">FilterAxis</code> optionally takes more than one filter. The filter either is an <code class="highlighter-rouge">XmlNameFilter</code>, to filter for names as for instance in elements and attributes, a value filter to filter text nodes or a node kind filter (<code class="highlighter-rouge">AttributeFilter</code>, <code class="highlighter-rouge">NamespaceFilter</code>, <code class="highlighter-rouge">CommentFilter</code>, <code class="highlighter-rouge">DocumentRootNodeFilter</code>, <code class="highlighter-rouge">ElementFilter</code>, <code class="highlighter-rouge">TextFilter</code> or <code class="highlighter-rouge">PIFilter</code> to filter processing instruction nodes).</p>

<p>In JSON object records have names and can be filtered with a <code class="highlighter-rouge">JsonNameFiler</code>. Available node kind filters are <code class="highlighter-rouge">ObjectFilter</code>,<code class="highlighter-rouge">ObjectRecordFilter</code>, <code class="highlighter-rouge">ArrayFilter</code>, <code class="highlighter-rouge">StringValueFilter</code>, <code class="highlighter-rouge">NumberValueFilter</code>, <code class="highlighter-rouge">BooleanValueFilter</code> and <code class="highlighter-rouge">NullValueFilter</code>.</p>

<p>Another example for using the  <code class="highlighter-rouge">FilterAxis</code> can also be used as follows for XML resources:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Filter by name (first argument is the axis, next arguments are filters</span>
<span class="c1">// (which implement org.sirix.axis.filter.Filter).</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VisitorDescendantAxis</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">rtx</span><span class="o">).</span><span class="na">includeSelf</span><span class="o">().</span><span class="na">visitor</span><span class="o">(</span><span class="n">myVisitor</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlNameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"foobar"</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">filterAxis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;</span><span class="nc">XdmNodeReadOnlyTrx</span><span class="o">&gt;(</span><span class="n">axis</span><span class="o">,</span> <span class="n">filter</span><span class="o">);</span> <span class="n">filterAxis</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
  <span class="n">filterAxis</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and for JSON-resources it’s again simply changing the generics argument from <code class="highlighter-rouge">XdmNodeReadOnlyTrx</code> to <code class="highlighter-rouge">JsonNodeReadOnlyTrx</code> as well as <code class="highlighter-rouge">XmlNameFilter</code> to <code class="highlighter-rouge">JsonNameFilter</code>.</p>

<p>Alternatively you can simply stream over your axis without using the <code class="highlighter-rouge">FilterAxis</code> at all and filter by a predicate. <code class="highlighter-rouge">rtx</code> is a <code class="highlighter-rouge">NodeReadOnlyTrx</code> in the following example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PostOrderAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axisStream</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">);</span>

<span class="n">axisStream</span><span class="o">.</span><span class="na">filter</span><span class="o">((</span><span class="n">unusedNodeKey</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">XmlNameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"a"</span><span class="o">))</span>
          <span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">unusedNodeKey</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="cm">/* Do something with the transactional cursor */</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="nested-axis">Nested Axis</h3>

<p>To achieve much more query power you can chain several axes with the <code class="highlighter-rouge">NestedAxis</code>. The following example shows how you can create axes to process a simple XPath query. However, we think it’s much more convenient to simply use the XPath query with our Brackit binding.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// XPath expression /p:a/b/text()</span>
<span class="c1">// Part: /p:a</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">childA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">NameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"p:a"</span><span class="o">));</span>
<span class="c1">// Part: /b</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">childB</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">NameFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="s">"b"</span><span class="o">));</span>
<span class="c1">// Part: /text()</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">TextFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">));</span>
<span class="c1">// Part: /p:a/b/text()</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NestedAxis</span><span class="o">(</span><span class="k">new</span> <span class="nc">NestedAxis</span><span class="o">(</span><span class="n">childA</span><span class="o">,</span> <span class="n">childB</span><span class="o">),</span> <span class="n">text</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="postorder-axis">PostOrder Axis</h3>

<p>You can use the <code class="highlighter-rouge">PostOrderAxis</code> in the following way:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A postorder-axis which iterates in postorder through a (sub)tree.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PostOrderAxis</span><span class="o">&lt;</span><span class="nc">XdmNodeReadOnlyTrx</span><span class="o">&gt;(</span><span class="n">rtx</span><span class="o">);</span> 
<span class="k">while</span> <span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
  <span class="c1">// Unique node identifier (nodeKey) however not needed here.</span>
  <span class="kd">final</span> <span class="kt">long</span> <span class="n">nodeKey</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="c1">// axis.getTrx() or directly use rtx.</span>
  <span class="k">switch</span><span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">getTrx</span><span class="o">().</span><span class="na">getKind</span><span class="o">())</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nl">TEXT:</span>
    <span class="c1">// Do something.</span>
    <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>or more elegantly:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Iterate and use a visitor implementation to describe the behavior for the individual</span>
<span class="c1">// node types.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">visitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyVisitor</span><span class="o">(</span><span class="n">rtx</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PostOrderAxis</span><span class="o">&lt;</span><span class="nc">XdmNodeReadOnlyTrx</span><span class="o">&gt;(</span><span class="n">rtx</span><span class="o">);</span> 
<span class="k">while</span> <span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">axis</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">rtx</span><span class="o">.</span><span class="na">acceptVisitor</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>or with the foreach-loop:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Iterate and use a visitor implementation to describe the behavior for</span>
<span class="c1">// the individual node types.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">visitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyVisitor</span><span class="o">(</span><span class="n">rtx</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">long</span> <span class="n">nodeKey</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">PostOrderAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">))</span> <span class="o">{</span>
  <span class="n">rtx</span><span class="o">.</span><span class="na">acceptVisitor</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="concurrent-axis">Concurrent Axis</h3>
<p>SirixDB also provides a <code class="highlighter-rouge">ConcurrentAxis</code> to fetch nodes concurrently. To execute an XPath-query as <code class="highlighter-rouge">//regions/africa//location</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NestedAxis</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">NestedAxis</span><span class="o">(</span>
            <span class="k">new</span> <span class="nc">ConcurrentAxis</span><span class="o">&lt;&gt;(</span><span class="n">firstConcurrRtx</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span>
                    <span class="k">new</span> <span class="nf">DescendantAxis</span><span class="o">(</span><span class="n">firstRtx</span><span class="o">,</span> <span class="nc">IncludeSelf</span><span class="o">.</span><span class="na">YES</span><span class="o">),</span>
                    <span class="k">new</span> <span class="nf">NameFilter</span><span class="o">(</span><span class="n">firstRtx</span><span class="o">,</span> <span class="s">"regions"</span><span class="o">))),</span>
            <span class="k">new</span> <span class="nc">ConcurrentAxis</span><span class="o">&lt;&gt;(</span><span class="n">secondConcurrRtx</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span>
                    <span class="k">new</span> <span class="nf">ChildAxis</span><span class="o">(</span><span class="n">secondRtx</span><span class="o">),</span>
                    <span class="k">new</span> <span class="nf">NameFilter</span><span class="o">(</span><span class="n">secondRtx</span><span class="o">,</span> <span class="s">"africa"</span><span class="o">)))),</span>
        <span class="k">new</span> <span class="nc">ConcurrentAxis</span><span class="o">&lt;&gt;(</span><span class="n">thirdConcurrRtx</span><span class="o">,</span>
            <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span>
                <span class="k">new</span> <span class="nf">DescendantAxis</span><span class="o">(</span><span class="n">thirdRtx</span><span class="o">,</span> <span class="nc">IncludeSelf</span><span class="o">.</span><span class="na">YES</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">NameFilter</span><span class="o">(</span><span class="n">thirdRtx</span><span class="o">,</span> <span class="s">"location"</span><span class="o">))));</span>
</code></pre></div></div>

<p>Note and beware of the different transactional cursors as constructor parameters (all opened on the same revision). SirixDB also provides a <code class="highlighter-rouge">ConcurrentUnionAxis</code>, a <code class="highlighter-rouge">ConcurrentExceptAxis</code> and a <code class="highlighter-rouge">ConcurrentIntersectAxis</code>. The transactional cursors can be of both types, <code class="highlighter-rouge">XdmNodeReadOnlyTrx</code> and <code class="highlighter-rouge">JsonNodeReadOnlyTrx</code>.</p>

<h3 id="predicate-axis">Predicate Axis</h3>
<p>In order to test for a predicate for instance to select all element nodes in an XML resource which have a child element with name “foo” we can use:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">childAxisFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FilterAxis</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">ChildAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">ElementFilter</span><span class="o">(</span><span class="n">rtx</span><span class="o">),</span> <span class="k">new</span> <span class="nc">NameFilter</span><span class="o">(</span><span class="s">"foo"</span><span class="o">));</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">descendantAxis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DescendantAxis</span><span class="o">();</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">predicateAxisFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PredicateFilterAxis</span><span class="o">(</span><span class="n">rtx</span><span class="o">,</span> <span class="n">childAxisFilter</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">nestedAxis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NestedAxis</span><span class="o">(</span><span class="n">descendantAxis</span><span class="o">,</span> <span class="n">predicateAxisFilter</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="time-travel-axes">Time Travel Axes</h3>
<p>However, SirixDB not only supports navigational axis within one revision, it also allows navigation on the time axis.</p>

<p>We’re able to use one of the following axes to navigate in time:
<code class="highlighter-rouge">FirstAxis</code>, <code class="highlighter-rouge">LastAxis</code>, <code class="highlighter-rouge">PreviousAxis</code>, <code class="highlighter-rouge">NextAxis</code>, <code class="highlighter-rouge">AllTimeAxis</code>, <code class="highlighter-rouge">FutureAxis</code>, <code class="highlighter-rouge">PastAxis</code>.</p>

<p>Each of the constructors of these time-travel axes takes a transactional cursor as the only parameter and opens the node, the cursor currently points to in each of the revisions (if it exists):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">axis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PastAxis</span><span class="o">(</span><span class="n">resourceManager</span><span class="o">,</span> <span class="n">rtx</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">axis</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">trx</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="c1">// Do something with the transactional cursor.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To use time travel axes, however first a few more revisions have to be created through committing a bunch of changes.</p>

<h3 id="navigational-methods">Navigational Methods</h3>

<p>You can then navigate the cursor to a specific node, either via axis and filters or, if you know the node key simply through the method <code class="highlighter-rouge">moveTo(long)</code>. The long parameter is the node key of the node you want to select.</p>

<p>SirixDB provides several navigational methods. After the resource is opened the cursor sits at a document root node, the only node which is present after bootstrapping a resource. You are then able to navigate to its first child which is the XML root element via <code class="highlighter-rouge">moveToFirstChild</code>. Similar, you can use the method <code class="highlighter-rouge">moveToRightSibling</code> to move the transactional cursor to the right sibling or to the left sibling via <code class="highlighter-rouge">moveToLeftSibling</code>. Furthermore, many more methods to navigate through the tree are available. For instance <code class="highlighter-rouge">moveToLastChild</code> or <code class="highlighter-rouge">moveToAttribute</code>/<code class="highlighter-rouge">moveToAttributeByName</code>/<code class="highlighter-rouge">moveToNamespace</code> if the cursor points to an element node. For JSON resources the moveTo-methods for attributes and namespaces are not available. Furthermore, SirixDB allows to move to the next node in preorder (<code class="highlighter-rouge">moveToNext</code>) or to the previous node in preorder (<code class="highlighter-rouge">moveToPrevious</code>). Or for instance to the next node on the XPath <code class="highlighter-rouge">following::</code>-axis. A simple example is this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A fluent call would be if you know a node has a right sibling and</span>
<span class="c1">// there's a first child of the right sibling.</span>
<span class="n">rtx</span><span class="o">.</span><span class="na">moveToRightSibling</span><span class="o">().</span><span class="na">trx</span><span class="o">().</span><span class="na">moveToFirstChild</span><span class="o">().</span><span class="na">trx</span><span class="o">();</span>

<span class="c1">// Can be tested before.</span>
<span class="k">if</span> <span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">hasRightSibling</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">rtx</span><span class="o">.</span><span class="na">moveToRightSibling</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Or test afterwards.</span>
<span class="k">if</span> <span class="o">(</span><span class="n">rtx</span><span class="o">.</span><span class="na">moveToRightSibling</span><span class="o">().</span><span class="na">hasMoved</span><span class="o">())</span> <span class="o">{</span>
  <span class="c1">// Do something.</span>
<span class="o">}</span>

<span class="c1">// Move to next node in the XPath following::-axis.</span>
<span class="n">rtx</span><span class="o">.</span><span class="na">moveToNextFollowing</span><span class="o">();</span>

<span class="c1">// Move to previous node in preorder.</span>
<span class="n">rtx</span><span class="o">.</span><span class="na">moveToPrevious</span><span class="o">();</span>

<span class="c1">// Move to next node in preorder.</span>
<span class="n">rtx</span><span class="o">.</span><span class="na">moveToNext</span><span class="o">();</span>
</code></pre></div></div>

<p>The API is fluent:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// trx() returns the transaction cursor currently used. However in this case the caller</span>
<span class="c1">// must be sure that a right sibling of the node denoted by node-key 15 and his right</span>
<span class="c1">// sibling and the right sibling's first child exists.</span>
<span class="n">wtx</span><span class="o">.</span><span class="na">moveTo</span><span class="o">(</span><span class="mi">15</span><span class="o">).</span><span class="na">trx</span><span class="o">()</span>
   <span class="o">.</span><span class="na">moveToRightSibling</span><span class="o">().</span><span class="na">trx</span><span class="o">()</span>
   <span class="o">.</span><span class="na">moveToFirstChild</span><span class="o">().</span><span class="na">trx</span><span class="o">()</span>
   <span class="o">.</span><span class="na">insertCommentAsFirstChild</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="open-and-modify-a-resource-in-a-database">Open and Modify a Resource in a Database</h2>

<p>First, you have to open the resource again.</p>

<h3 id="open-a-read-write-transaction-in-an-xml-database">Open a Read-Write Transaction in an XML Database</h3>

<p>To open a resource in an XML database you can use:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openXmlDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
     <span class="c1">// Now open a read/write transaction again.</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">wtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">())</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="open-a-read-write-transaction-in-a-json-database">Open a Read-Write Transaction in a JSON Database</h3>

<p>To open a resource in a JSON database you can use:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Open the database.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">database</span> <span class="o">=</span> <span class="nc">Databases</span><span class="o">.</span><span class="na">openJsonDatabase</span><span class="o">(</span><span class="n">databaseFile</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">openResourceManager</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>
     <span class="c1">// Now open a read/write transaction again.</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">wtx</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">())</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Thus, the only visible change in the API regarding JSON and XML resources is the method call <code class="highlighter-rouge">Databases.openJsonDatabase</code>
instead of <code class="highlighter-rouge">Databases.openXmlDatabase</code>. Note, that also the types of the database/resource and transaction have changed, but for brevity we use Java’s type inference rules and the <code class="highlighter-rouge">var</code> keyword. Note, that you have to use a read-write transaction, which is able to modify the resource (of type <code class="highlighter-rouge">NodeTrx</code>) instead of a read-only transaction (<code class="highlighter-rouge">beginNodeTrx</code> instead of <code class="highlighter-rouge">beginNodeReadOnlyTrx</code>). Thus, you have to start the single read-write transaction on a resource and make sure, that you commit and properly close the transaction.</p>

<p>Note, that it’s best to open the transaction in the enclosing <code class="highlighter-rouge">try-with-resources</code> statement. You can reuse the transaction handle after issuing a <code class="highlighter-rouge">commit</code>.</p>

<h3 id="simple-update-methods">Simple Update Methods</h3>

<p>Once you’ve navigated to the node you want to change, you can either update, for instance, the name or the value depending on the node type.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cursor resides on an element node.</span>
<span class="k">if</span> <span class="o">(</span><span class="n">wtx</span><span class="o">.</span><span class="na">isElement</span><span class="o">())</span> <span class="n">wtx</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="k">new</span> <span class="nc">QNm</span><span class="o">(</span><span class="s">"foo"</span><span class="o">))</span>

<span class="c1">// Or a text node</span>
<span class="k">if</span> <span class="o">(</span><span class="n">wtx</span><span class="o">.</span><span class="na">isText</span><span class="o">())</span> <span class="n">wtx</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
</code></pre></div></div>

<p>or for JSON resources:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cursor resides on an object key.</span>
<span class="k">if</span> <span class="o">(</span><span class="n">wtx</span><span class="o">.</span><span class="na">isObjectKey</span><span class="o">())</span> <span class="n">wtx</span><span class="o">.</span><span class="na">setObjectKeyName</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>

<span class="c1">// Or a string value node node</span>
<span class="k">if</span> <span class="o">(</span><span class="n">wtx</span><span class="o">.</span><span class="na">isStringValue</span><span class="o">())</span> <span class="n">wtx</span><span class="o">.</span><span class="na">setStringValue</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
</code></pre></div></div>

<p>Or you can insert new elements via <code class="highlighter-rouge">insertElementAsFirstChild</code>, <code class="highlighter-rouge">insertElementAsLeftSibling</code> and <code class="highlighter-rouge">insertElementAsRightSibling</code>. Similar methods exist for all other node types. We for sure always check for consistency and if calling the method on a specific node type should be allowed or not.</p>

<p>Attributes for instance can only be inserted via <code class="highlighter-rouge">insertAttribute</code>, if the cursor is located on an element node.</p>

<p>Updating methods can also be chained:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assertion: wtx is located at element node.</span>
<span class="n">wtx</span><span class="o">.</span><span class="na">insertAttribute</span><span class="o">(</span><span class="k">new</span> <span class="nc">QNm</span><span class="o">(</span><span class="s">"foo"</span><span class="o">),</span> <span class="s">"bar"</span><span class="o">,</span> <span class="nc">Move</span><span class="o">.</span><span class="na">PARENT</span><span class="o">)</span>
   <span class="o">.</span><span class="na">insertElementAsRightSibling</span><span class="o">(</span><span class="k">new</span> <span class="nc">QNm</span><span class="o">(</span><span class="s">"baz"</span><span class="o">));</span>
</code></pre></div></div>

<p>You can insert new object records via <code class="highlighter-rouge">insertObjectRecordAsFirstChild</code> and <code class="highlighter-rouge">insertObjectRecordAsRightSibling</code> in JSON resources. Similar methods exist for all node types. Object records are composed of two nodes: An object key node and an object value node.</p>

<p>SirixDB checks for consistency and as such it throws an unchecked <code class="highlighter-rouge">SirixUsageException</code> if a method call is not permitted on a specific node type.</p>

<p>Object records, that is key/value pairs, for instance, can only be inserted as a first child if the cursor is located on an object node. In the following we’ll insert both an object key node as well as one of the other node types as the value with the insertObjectRecordAsX methods.</p>

<p>You can also chain the update methods – for this example, wtx is located on an object node:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wtx</span><span class="o">.</span><span class="na">insertObjectRecordAsFirstChild</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StringValue</span><span class="o">(</span><span class="s">"bar"</span><span class="o">))</span>
   <span class="o">.</span><span class="na">moveToParent</span><span class="o">().</span><span class="na">trx</span><span class="o">()</span>
   <span class="o">.</span><span class="na">insertObjectRecordAsRightSibling</span><span class="o">(</span><span class="s">"baz"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">NullValue</span><span class="o">());</span>
</code></pre></div></div>

<p>First, the transaction inserts an object key node with the name “foo” as the first child of an object node. Then, a <code class="highlighter-rouge">StringValueNode</code> is created as the first child of the newly created object key node.</p>

<p>The cursor is moved to the value node after the method call. Thus, you first have to move the cursor to the object key node, the parent again. Then, you’re able to insert the next object key node and its child, a <code class="highlighter-rouge">NullValueNode</code> as a right sibling.</p>

<h3 id="bulk-update-operations">Bulk Update Operations</h3>

<p>More sophisticated bulk insertion methods exist, too as you have already seen when we imported an XML document or JSON data. We provide a method to insert an XML fragment as a first child <code class="highlighter-rouge">insertSubtreeAsFirstChild</code>, as a left sibling <code class="highlighter-rouge">insertSubtreeAsLeftSibling</code> and as a right sibling <code class="highlighter-rouge">insertSubtreeAsRightSibling</code>.</p>

<p>To insert a new subtree based on a String you can simply use</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wtx</span><span class="o">.</span><span class="na">insertSubtreeAsFirstChild</span><span class="o">(</span><span class="nc">XmlShredder</span><span class="o">.</span><span class="na">createStringReader</span><span class="o">(</span><span class="s">"&lt;foo&gt;bar&lt;baz/&gt;&lt;/foo&gt;"</span><span class="o">))</span>
</code></pre></div></div>

<p>To insert a new subtree into a JSON resource:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var json = "{\"foo\": \"bar\",\"baz\": [0, \"bla\", true, null]}";
wtx.insertSubtreeAsFirstChild(JsonShredder.createStringReader(json));
</code></pre></div></div>

<p>To copy a subtree of the node the read-transaction (<code class="highlighter-rouge">rtx</code>) is located at as a new right sibling.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wtx</span><span class="o">.</span><span class="na">copySubtreeAsRightSibling</span><span class="o">(</span><span class="n">rtx</span><span class="o">);</span>
</code></pre></div></div>

<p>SirixDB always applies changes in-memory and then flushes them sequentially to a disk or the flash drive during a transaction commit. The only exception is if the in-memory cache has to evict some entries into a file due to memory constraints. We can either commit() or rollback() the transaction. Note, that you can reuse the transaction after a commit() or rollback() method call.</p>

<h3 id="starting-a-read-write-transaction">Starting a Read-Write Transaction</h3>

<p>SirixDB provides several possibilities to start a read-write transaction in the first place. You can for instance start an auto-commit transactional cursor:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Auto-commit every 30 seconds.</span>
<span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span>
<span class="c1">// Auto-commit after every 1000th modification.</span>
<span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="c1">// Auto-commit every 30 seconds and every 1000th modification.</span>
<span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span>
</code></pre></div></div>

<p>Furthermore, you’re able to start a read-write transaction and then revert to a former revision:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Open a read/write transaction on the most recent revision, then revert to revision two and commit as a new revision.</span>
<span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeTrx</span><span class="o">().</span><span class="na">revertTo</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">commit</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="open-specific-revisions">Open Specific Revisions</h2>

<p>Once you’ve committed more than one revision you can open it either by specifying the exact revision number or by a timestamp.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// To open a transactional read-only cursor on revision two.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">rtx</span> <span class="o">=</span> <span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeReadOnlyTrx</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="c1">// Or by a timestamp:</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2019</span><span class="o">,</span> <span class="nc">Month</span><span class="o">.</span><span class="na">JUNE</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">39</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">instant</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Europe/Berlin"</span><span class="o">)).</span><span class="na">toInstant</span><span class="o">();</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">rtx</span> <span class="o">=</span> <span class="n">resourceManager</span><span class="o">.</span><span class="na">beginNodeReadOnlyTrx</span><span class="o">(</span><span class="n">instant</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="serialize-a-resource-in-a-database">Serialize a Resource in a Database</h2>

<h3 id="serialize-as-xml">Serialize as XML</h3>

<p>In order to serialize the (most recent) revision of a resource in an XML database pretty printed to STDOUT:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="nc">XmlSerializer</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">manager</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">).</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
<span class="n">serializer</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</code></pre></div></div>

<p>Or write it to string:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">baos</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="nc">XmlSerializer</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">manager</span><span class="o">,</span> <span class="n">writer</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">prettyPrint</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">serializer</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">content</span> <span class="o">=</span> <span class="n">baos</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
</code></pre></div></div>

<p>In order to serialize revision 1, 2 and 3 of a resource with an XML declaration and the internal node keys for element nodes (pretty printed):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="nc">XmlSerializer</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">manager</span><span class="o">,</span> <span class="n">out</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">emitXMLDeclaration</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">emitIds</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">prettyPrint</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">serialize</span><span class="o">.</span><span class="na">call</span><span class="o">()</span>
</code></pre></div></div>

<p>In order to serialize all stored revisions with the internal node keys and pretty printed:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="nc">XmlSerializer</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">manager</span><span class="o">,</span> <span class="n">out</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">emitXMLDeclaration</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">emitIds</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">prettyPrint</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">serialize</span><span class="o">.</span><span class="na">call</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="serialize-to-json">Serialize to JSON</h3>
<p>Serializing a resource from a JSON database is very similar:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JsonSerializer</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">resourceManager</span><span class="o">,</span> <span class="n">writer</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="n">serializer</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</code></pre></div></div>
<p>Here you’re serializing the most recent revision.</p>

<p>To serialize revision 1 and 2:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="k">new</span>
<span class="nc">JsonSerializer</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">resourceManager</span><span class="o">,</span> <span class="n">writer</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="n">serializer</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</code></pre></div></div>

<p>And all stored revisions:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="k">new</span>
<span class="nc">JsonSerializer</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">resourceManager</span><span class="o">,</span> <span class="n">writer</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="n">serializer</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="diffing">Diffing</h2>

<h3 id="import-differences">Import Differences</h3>

<p>To update a resource with algorithmically found differences between an initially stored revision in a SirixDB resource and another revision stored as an XML document, you can use:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old Sirix resource to update.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">resOldRev</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"resource"</span><span class="o">);</span>

<span class="c1">// XML document which should be imported as the new revision.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">resNewRev</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"foo.xml"</span><span class="o">);</span>

<span class="c1">// Determine and import differences between the sirix resource and the</span>
<span class="c1">// provided XML document.</span>
<span class="k">new</span> <span class="nf">FMSEImport</span><span class="o">().</span><span class="na">xmlDataImport</span><span class="o">(</span><span class="n">resOldRev</span><span class="o">,</span> <span class="n">resNewRev</span><span class="o">);</span>
</code></pre></div></div>
:ET