I"‰=<h2 id="maven-artifacts">Maven Artifacts</h2>

<p>First, you have to get the dependeny on our Sirix XQuery project. At this stage of development please use the latest SNAPSHOT artifacts from the OSS snapshot repository. Just add the following repository section to your POM file:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;repository&gt;</span>
  <span class="nt">&lt;id&gt;</span>sonatype-nexus-snapshots<span class="nt">&lt;/id&gt;</span>
  <span class="nt">&lt;name&gt;</span>Sonatype Nexus Snapshots<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;url&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="nt">&lt;/url&gt;</span>
  <span class="nt">&lt;releases&gt;</span>
    <span class="nt">&lt;enabled&gt;</span>false<span class="nt">&lt;/enabled&gt;</span>
  <span class="nt">&lt;/releases&gt;</span>
  <span class="nt">&lt;snapshots&gt;</span>
    <span class="nt">&lt;enabled&gt;</span>true<span class="nt">&lt;/enabled&gt;</span>
  <span class="nt">&lt;/snapshots&gt;</span>
<span class="nt">&lt;/repository&gt;</span>
</code></pre></div></div>

<p>Or for Gradle:</p>
<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'java'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'maven'</span>

<span class="k">repositories</span> <span class="o">{</span>
    <span class="n">maven</span> <span class="o">{</span>
          <span class="n">url</span> <span class="s2">"https://oss.sonatype.org/content/repositories/snapshot"</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, if you prefer, we just released version 0.9.3 of Sirix in Maven Central.</p>

<p>Maven artifacts are deployed to the central maven repository (however please use the SNAPSHOT-variants as of now). Currently the following artifacts are available. Make sure that snapshots are getting updated with newer versions in your IDE.</p>

<p>Core project:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.sirix<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>sirix-xquery<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>0.9.4-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>To add the dependency in Gradle:</p>
<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">dependencies</span> <span class="o">{</span>
  <span class="n">compile</span> <span class="s1">'io.sirix:sirix-xquery:0.9.4-SNAPSHOT'</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="import-and-query">Import and Query</h2>
<p>First, we might want to import an XML document into Sirix. Weâ€™ll create a database with the imported XML document as a single resource file with the XQuery function <code class="highlighter-rouge">sdb:load(xs:string, xs:string, xs:string) as node()</code>. The first argument is the database to create, the second the resource which represents the imported XML-document and the third parameter is the resource to import. Then weâ€™ll be able to load the resource again and execute our first query (<code class="highlighter-rouge">sdb:doc('mydoc.col', 'mydoc.xml')/Organization/Project[@id='4711']</code>):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">doc</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"src"</span><span class="o">,</span> <span class="s">"main"</span><span class="o">,</span> <span class="s">"resources"</span><span class="o">,</span> <span class="s">"orga.xml"</span><span class="o">);</span>

<span class="c1">// Initialize query context and store.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// Use XQuery to load sample document into store.</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Loading document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">docUri</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="na">toUri</span><span class="o">();</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">queryLoadIntoSirix</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"sdb:load('mydoc.col', 'mydoc.xml', '%s')"</span><span class="o">,</span> <span class="n">docUri</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queryLoadIntoSirix</span><span class="o">);</span>
  <span class="k">new</span> <span class="nf">XQuery</span><span class="o">(</span><span class="n">queryLoadIntoSirix</span><span class="o">).</span><span class="na">evaluate</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query loaded document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"sdb:doc('mydoc.col', 'mydoc.xml')/Organization/Project[@id='4711']"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">query</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the above example we are importing (loading) an XML document from a file into SirixDB. We can import XML documents stored as simple Strings with the store-function:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:store</span><span class="p">(</span><span class="s">'mydoc.col'</span><span class="o">,</span><span class="w"> </span><span class="s">'mydoc.xml'</span><span class="o">,</span><span class="w"> </span><span class="s">'&lt;xml&gt;foo&lt;bar/&gt;&lt;/xml&gt;'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Loading a collection of XML files in SirixDB is as simple as using the following query. <code class="highlighter-rouge">dir</code> is a directory path and weâ€™re importing all files with an <code class="highlighter-rouge">.xml</code> suffix:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">final</span><span class="w"> </span><span class="nt">var</span><span class="w"> </span><span class="nt">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">SirixQueryContext.createWithNodeStore</span><span class="p">(</span><span class="nt">store</span><span class="p">);</span><span class="w">
</span><span class="nt">final</span><span class="w"> </span><span class="nt">var</span><span class="w"> </span><span class="nt">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">String.format</span><span class="p">(</span><span class="s">"bit:load('mydocs.col', io:ls('%s', '\\.xml$'))"</span><span class="o">,</span><span class="w"> </span><span class="nt">dir</span><span class="p">);</span><span class="w">
</span><span class="nt">new</span><span class="w"> </span><span class="nf">XQuery</span><span class="p">(</span><span class="nt">query</span><span class="p">)</span><span class="o">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="nt">ctx</span><span class="p">);</span><span class="w">
</span></code></pre></div></div>

<p>And querying the collection is as simple as using the function collection:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="w"> </span><span class="nv">$doc</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">collection</span><span class="p">(</span><span class="s">'mydocs.col'</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">$doc</span><span class="w">
</span></code></pre></div></div>

<p>In order to store JSON data in SirixDB we can use the store-function within another namespace (<code class="highlighter-rouge">js</code>):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Initialize query context and store.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicJsonDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithJsonStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">chain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithJsonStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// Use XQuery to store a JSON string into the store.</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Storing document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">storeQuery</span> <span class="o">=</span> <span class="s">"jn:store('mycol.jn','mydoc.jn','[\"bla\", \"blubb\"]')"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">storeQuery</span><span class="o">);</span>
  <span class="k">new</span> <span class="nf">XQuery</span><span class="o">(</span><span class="n">chain</span><span class="o">,</span> <span class="n">storeQuery</span><span class="o">).</span><span class="na">evaluate</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can also store a bunch of JSON-strings within several resources in the database (<code class="highlighter-rouge">mycol.jn</code>):</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">jn:store</span><span class="p">(</span><span class="s">'mycol.jn'</span><span class="o">,</span><span class="p">()</span><span class="o">,</span><span class="p">(</span><span class="s">'["bla", "blubb"]'</span><span class="o">,</span><span class="s">'{"foo": true}'</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>In that case the second parameter, which otherwise denotes the resource name is not used. Furthermore in both cases the database is implicitly created. However, a fourth boolean parameter can be used to add resources. It is <code class="highlighter-rouge">true()</code> if a new database should be created or <code class="highlighter-rouge">false()</code> if the resource should be added to an existing database:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">jn:store</span><span class="p">(</span><span class="s">'mycol.jn'</span><span class="o">,</span><span class="s">'mydoc.jn'</span><span class="o">,</span><span class="s">'["foo", "bar"]'</span><span class="o">,</span><span class="nf">false</span><span class="p">())</span><span class="w">
</span></code></pre></div></div>

<p>In this case the resource is added to the <code class="highlighter-rouge">mycol.jn</code> database as <code class="highlighter-rouge">mydoc.jn</code>.</p>

<p>We can open the stored resources again, either via a jn:collection(â€¦) function to retrieve all resources in a database:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="w"> </span><span class="nv">$doc</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">jn:collection</span><span class="p">(</span><span class="s">'mydocs.col'</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">$doc</span><span class="w">
</span></code></pre></div></div>

<p>or via <code class="highlighter-rouge">jn:doc(xs:string, xs:string, xs:int) as json-item()</code>, which is almost identical as the version to open XML resources. The first parameter is the database to open, the second parameter the resource and the last parameter is the optional revision to open. Without the last parameter SirixDB opens the most recent revision.</p>

<p>For instance if we have stored the following very JSON-string as a resource in SirixDB <code class="highlighter-rouge">{"sirix":{"revisionNumber":1}}</code>, then weâ€™ll be able to retrieve the revisionNumber simply via:</p>

<p><code class="highlighter-rouge">jn:doc('mycol.jn','mydoc.jn')=&gt;sirix=&gt;revisionNumber</code></p>

<p>This example query shows the <code class="highlighter-rouge">deref</code>-operator <code class="highlighter-rouge">=&gt;</code> which is used to select object values by their key name.</p>

<p>Weâ€™ll save other JSON examples for later. First, we want to show how to update XML and JSON resources.</p>

<h3 id="update-a-resource">Update a Resource</h3>

<p>In order to update a resource weâ€™re able to use XQuery Update statements. First we load an XML document again into a resource in a (to be created) database. The database is named <code class="highlighter-rouge">mycol.xml</code> and the resource <code class="highlighter-rouge">mydoc.xml</code>. Then we open the database and the resource again. We open the resource in its most recent revision and insert an XML fragment (<code class="highlighter-rouge">&lt;a&gt;&lt;b/&gt;&lt;/a&gt;</code>) as a first child into the root element log. We serialize the result to <code class="highlighter-rouge">STDOUT</code> again.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Prepare sample document.</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">generateSampleDoc</span><span class="o">(</span><span class="s">"sample"</span><span class="o">);</span>

<span class="c1">// Initialize query context and store.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="c1">// Use XQuery to load sample document into store.</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Loading document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">docUri</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="na">toUri</span><span class="o">();</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">xq1</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"sdb:load('mycol.xml', 'mydoc.xml', '%s')"</span><span class="o">,</span> <span class="n">docUri</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">xq1</span><span class="o">);</span>
  <span class="k">new</span> <span class="nf">XQuery</span><span class="o">(</span><span class="n">xq1</span><span class="o">).</span><span class="na">evaluate</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>

  <span class="c1">// Reuse store and query loaded document.</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query loaded document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">xq2</span> <span class="o">=</span> <span class="s">"let $doc := sdb:doc('mycol.xml', 'mydoc.xml')\n"</span> <span class="o">+</span> <span class="s">"let $log = $doc/log return \n"</span>
    <span class="o">+</span> <span class="s">"( insert nodes &lt;a&gt;&lt;b/&gt;&lt;/a&gt; into $log )\n"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">xq2</span><span class="o">);</span>
  <span class="k">new</span> <span class="nf">XQuery</span><span class="o">(</span><span class="n">xq2</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>

  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="s">"sdb:doc('mycol.xml', 'mydoc.xml')"</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Note, that a transaction is auto-commited in this case and that the element nodes <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> are stored in a new revision. Thus, in this case we open the most recent revision, which is revision two. After creating and bootstrapping a resource the revision number is 0 with only a document-root node. Once we commit our imported XML-document we have stored a first revision. Weâ€™re serializing the stored revision in another query to <code class="highlighter-rouge">STDOUT</code> again.</p>

<p>SirixDB currently doesnâ€™t support update expressions for the JSON-XQuery extension. For now we have to use the transactional cursor based API to update JSON resources. We can simply open the database with XQuery and get the transactional cursor via the <code class="highlighter-rouge">getTrx()</code>-method on the result sequence:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">var</span> <span class="n">seq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">query</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">rtx</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">getTrx</span><span class="o">();</span>
</code></pre></div></div>

<p>In Java or Kotlin we can use the transaction to insert Object-structures, Arrays, String, Number, Boolean and Null-values.</p>

<p>For instance we can insert JSON data as first childs of arrays or as right siblings of array items:</p>

<p><code class="highlighter-rouge">JsonNodeTrx insertSubtreeAsFirstChild(JsonReader reader)</code></p>

<p><code class="highlighter-rouge">JsonNodeTrx insertSubtreeAsRightSibling(JsonReader reader)</code></p>

<p>If the cursor is located on an object node we can insert records (key/value pairs):</p>

<p><code class="highlighter-rouge">JsonNodeTrx insertObjectRecordAsFirstChild(String key, ObjectRecordValue&lt;?&gt; value)</code></p>

<p>Object record values can be all JSON node types (<code class="highlighter-rouge">ArrayValue</code>, <code class="highlighter-rouge">ObjectValue</code>, <code class="highlighter-rouge">BooleanValue</code>, <code class="highlighter-rouge">StringValue</code>, <code class="highlighter-rouge">NumberValue</code> and <code class="highlighter-rouge">NullValue</code>). If the cursor is located on an object key you can insert other JSON records as right siblings:</p>

<p><code class="highlighter-rouge">JsonNodeTrx insertObjectRecordAsRightSibling(String key, ObjectRecordValue&lt;?&gt; value)</code></p>

<p>We can find alls possible methods in the interface <code class="highlighter-rouge">org.sirix.api.json.JsonNodeTrx</code>.</p>

<h3 id="temporal-axis">Temporal axis</h3>
<p>SirixDB not only provides all standard XPath axes for the stored XML documents, but also temporal XPath axes. We can use these axes to analyse how a resource or a subtree therein has changed between several revisions.</p>

<p>Temporal axis are compatible with node tests:</p>

<p><code class="highlighter-rouge">&lt;temporalaxis&gt;::&lt;nodetest&gt;</code> is defined as <code class="highlighter-rouge">&lt;temporalaxis&gt;::*/self::&lt;nodetest&gt;</code></p>

<p>For instance to simply serialize all revisions, we can use the axis <code class="highlighter-rouge">all-times::</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query loaded document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">queryString</span> <span class="o">=</span> <span class="s">"sdb:doc('mycol.xml', 'mydoc.xml')/log/all-times::*"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queryString</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">queryString</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>SirixDB supports a lot of temporal axis: <code class="highlighter-rouge">first::</code> to get a node in the first revision, <code class="highlighter-rouge">last::</code> to get a node in the last revision, <code class="highlighter-rouge">previous::</code> to get the node in the previous revision, <code class="highlighter-rouge">next::</code> to get the node in the next revision, <code class="highlighter-rouge">future::</code> and <code class="highlighter-rouge">future-or-self::</code> to get a node in all future revisions or the current and future revisions, <code class="highlighter-rouge">past::</code> and <code class="highlighter-rouge">past-or-self::</code> to get a node in past revisions or the current and past revisions. We have already seen the <code class="highlighter-rouge">all-times::</code>-axis which iterates over a node in all revisions.</p>

<p>JSON instead has no notion of navigational axis, instead SirixDB provides custom functions:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">jn:future($item as json-item(), $includeSelf as xs:boolean) as json-item()*</code>: Function for selecting a json-item in the future or the future-or-self. The first parameter is the context item. Second parameter denotes if the current item should be included in the result or not.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:past($item as json-item(), $includeSelf as xs:boolean) as json-item()*</code>: Function for selecting a json-item in the past or the past-or-self. The first parameter is the context item. Second parameter denotes if the current item should be included in the result or not.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:all-times($item as json-item()) as json-item()+</code>: Function for selecting a json-item in all revisions.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:first($item as json-item()) as json-item()?</code>: Function for selecting a json-item in the first revision.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:last($item as json-item()) as json-item()?</code>: Function for selecting a json-item in the last / most-recent revision.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:previous($item as json-item()) as json-item()?</code>: Function for selecting a json-item in the previous revision.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">jn:next($item as json-item()) as json-item()?</code>: Function for selecting a json-item in the next revision.</p>
  </li>
</ul>

<h3 id="open-a-specific-revision">Open a Specific Revision</h3>
<p>Once weâ€™ve stored a few revisions of a resource in SirixDB we might want to open a specific revision again. We can use the <code class="highlighter-rouge">doc</code> function again, but this time with a third parameter:</p>

<p><code class="highlighter-rouge">sdb:doc('mycol.xml', 'mydoc.xml', 1)</code></p>

<p>SirixDB opens the database <code class="highlighter-rouge">mycol.xml</code> and the resource <code class="highlighter-rouge">mydoc.xml</code> in revision one. Without the additional revision-number parameter SirixDB would have opened the most recent revision.</p>

<p>However, we might also want to load a revision by a given point in time. Weâ€™re able to use the function <code class="highlighter-rouge">sdb:open($database as xs:string, $resource as xs:string, $pointInTime as xs:dateTime) as $doc</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query loaded document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">queryString</span> <span class="o">=</span> <span class="s">"sdb:open('mycol.xml', 'mydoc.xml', xs:dateTime(\"2019-04-01T05:00:00-00:00\"))/log"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">xq3</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">queryString</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>We open the resource in the database as it looked like on 2019-04-01 05:00:00.</p>

<p>With the function <code class="highlighter-rouge">open-revisions</code> weâ€™re able to load all revisions of a resource between two points in time:</p>

<p><code class="highlighter-rouge">sdb:open-revisions($database as xs:string, $resource as xs:string, $startDateTime as xs:dateTime, $endDateTime as xs:dateTime) as node()*</code></p>

<p>For instance we can use the following Java code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">()</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
    <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query loaded document:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">queryString</span> <span class="o">=</span> <span class="s">"sdb:open('mycol.xml', 'mydoc.xml', xs:dateTime(\"2018-04-01T05:00:00-00:00\"), xs:dateTime(\"2019-04-01T05:00:00-00:00\"))"</span><span class="o">;</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queryString</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">queryString</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">().</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="transactional-cursor-based-functions">Transactional-Cursor Based Functions</h3>
<p>SirixDB also provides a few functions, which are based on the fact that currently when importing data with XQuery we generate hashes for each node as well as the number of descendants. Furthermore we always store the number of children of each node. You can use the function</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:descendant-count</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:long</span><span class="w">
</span></code></pre></div></div>

<p>to retrieve the number of descendants of a node,</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:child-count</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:int</span><span class="w">
</span></code></pre></div></div>

<p>to retrieve the number of children of a node and</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:hash</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:string</span><span class="w">
</span></code></pre></div></div>

<p>to retrieve the stored hash of a node.</p>

<p>With the function</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:attribute-count</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:int</span><span class="w">
</span></code></pre></div></div>

<p>youâ€™ll get the number of attributes of a node (an element node).</p>

<p>You can get the most recent revision number with the function</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:most-recent-revision</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:int</span><span class="w">
</span></code></pre></div></div>

<p>You can get the unique, stable key/ID of a node with</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:nodekey</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:long</span><span class="w">
</span></code></pre></div></div>

<p>To commit a transaction if no auto-commit is enabled</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:commit</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:node</span><span class="w">
</span></code></pre></div></div>

<p>To rollback a transaction (result item is the aborted revision number)</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:rollback</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:int</span><span class="w">
</span></code></pre></div></div>

<p>To get the revision timestamp of a node (the timestamp when the transaction has been committed)</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sdb:timestamp</span><span class="p">(</span><span class="nv">$node</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">structured-item</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">xs:dateTime</span><span class="w">
</span></code></pre></div></div>

<h2 id="json-extension-beta">JSON Extension (Beta)</h2>

<p>We copied the description if the JSON extension in Brackit, the XQuery compiler we are using:</p>

<p>Brackit features a seamless integration of JSON-like objects and arrays directly at the language level.</p>

<p>You can easily mix arbitrary XML and JSON data in a single query or simply use brackit to convert data from one format into the other. This allows you to get the most out of your data.</p>

<p>The language extension allows you to construct and operate JSON data directly; additional utility functions help you to perform typical tasks.</p>

<p>Everything is designed to simplify joint processing of XDM and JSON and to maximize the freedom of developers. Thus, our extension effectively supports some sort of superset of XDM and JSON. That means, it is possible to create arrays and objects which do not strictly conform to the JSON RFC. Itâ€™s up to you to decide how you want to have your data look like!</p>

<h3 id="arrays">Arrays</h3>

<p>Arrays can be created using an extended version of the standard JSON array syntax:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(: statically create an array with 3 elements of different types: 1, 2.0, "3" :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="mf">2.0</span><span class="o">,</span><span class="w"> </span><span class="s">"3"</span><span class="w"> </span><span class="p">]</span><span class="w">

</span><span class="c">(: for compliance with the JSON syntax the tokens 'true', 'false', and 'null'
   are translated into the XML values xs:bool('true'), xs:bool('false') and empty-sequence()
:)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="nt">true</span><span class="o">,</span><span class="w"> </span><span class="nt">false</span><span class="o">,</span><span class="w"> </span><span class="nt">null</span><span class="w"> </span><span class="p">]</span><span class="w">

</span><span class="c">(: is different to :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="nt">true</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nt">false</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nt">null</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="c">(: where each field is initialized as the result of a path expression
   starting from the current context item, e,g., './true'
:)</span><span class="w">

</span><span class="c">(: dynamically create an array by evaluating some expressions: :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="m">1</span><span class="o">+</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nf">substring</span><span class="p">(</span><span class="s">"banana"</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="o">,</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c">(: yields the array [ 2, "nana", () ] :)</span><span class="w">

</span><span class="c">(: arrays can be nested and fields can be arbitrary sequences :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="ow">to</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c">(: yields an array of length 1: [(1,2,3,4,5)] :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="k">some</span><span class="w"> </span><span class="k">text</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c">(: yields an array of length 1 with an XML fragment as field value :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="s">'x'</span><span class="o">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">'y'</span><span class="w"> </span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="s">'z'</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c">(: yields an array of length 3: [ 'x' , ['y'], 'z' ] :)</span><span class="w">

</span><span class="c">(: a preceding '=' distributes the items of a sequence to individual array positions :)</span><span class="w">
</span><span class="p">[</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="ow">to</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c">(: yields an array of length 5: [ 1, 2, 3, 4, 5 ] :)</span><span class="w">

</span><span class="c">(: array fields can be accessed by the '[[ ]]' postfix operator: :)</span><span class="w">
</span><span class="k">let</span><span class="w"> </span><span class="nv">$a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">"Jim"</span><span class="o">,</span><span class="w"> </span><span class="s">"John"</span><span class="o">,</span><span class="w"> </span><span class="s">"Joe"</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">$a</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="c">(: yields the string "John" :)</span><span class="w">

</span><span class="c">(: the function bit:len() returns the length of an array :)</span><span class="w">
</span><span class="nf">bit:len</span><span class="p">([</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="c">(: yields 2 :)</span><span class="w">
</span></code></pre></div></div>

<h3 id="records">Records</h3>

<p>Records provide an alternative to XML to represent structured data. Like with arrays we support an extended version of the standard JSON object syntax:</p>

<div class="language-xquery highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(: statically create a record with three fields named 'a', 'b' and 'c' :)</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="s">"a"</span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="s">"b"</span><span class="o">:</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="s">"c"</span><span class="o">:</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">}</span><span class="w">

</span><span class="c">(: for compliance with the JSON syntax the tokens 'true', 'false', and 'null'
   are translated into the XML values xs:bool('true'), xs:bool('false') and empty-sequence()
:)</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="s">"a"</span><span class="o">:</span><span class="w"> </span><span class="nt">true</span><span class="o">,</span><span class="w"> </span><span class="s">"b"</span><span class="o">:</span><span class="w"> </span><span class="nt">false</span><span class="o">,</span><span class="w"> </span><span class="s">"c"</span><span class="o">:</span><span class="w"> </span><span class="nt">null</span><span class="p">}</span><span class="w">

</span><span class="c">(: field names are modelled as xs:QName and may be set in double quotes,
   single quotes or completely without quotes.
:)</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="nt">a</span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="s">'b'</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="s">"c"</span><span class="o">:</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">}</span><span class="w">

</span><span class="c">(: field values may be arbitrary expressions:)</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nf">concat</span><span class="p">(</span><span class="s">'f'</span><span class="o">,</span><span class="w"> </span><span class="s">'oo'</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="w"> </span><span class="s">'b'</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">+</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nt">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="o">,</span><span class="m">2</span><span class="o">,</span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c">(: yields {a : "foo", b : 2, c : [1,2,3]} :)</span><span class="w">

</span><span class="c">(: field values are defined by key-value pairs or by an expression
   that evaluates to a record
:)</span><span class="w">
</span><span class="k">let</span><span class="w"> </span><span class="nv">$r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">x</span><span class="o">:</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nt">y</span><span class="o">:</span><span class="m">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nv">$r</span><span class="o">,</span><span class="w"> </span><span class="nt">z</span><span class="o">:</span><span class="m">3</span><span class="p">}</span><span class="w"> </span><span class="c">(: yields {x: 1, y: 2, z: 3} :)</span><span class="w">

</span><span class="c">(: fields may be selectively projected into a new record :)</span><span class="w">
</span><span class="p">{</span><span class="nt">x</span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nt">y</span><span class="o">:</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nt">z</span><span class="o">:</span><span class="w"> </span><span class="m">3</span><span class="p">}{</span><span class="nt">z</span><span class="o">,</span><span class="nt">y</span><span class="p">}</span><span class="w"> </span><span class="c">(: yields {z: 3, y: 2} :)</span><span class="w">

</span><span class="c">(: values of record field can be accessed using the deref operator '=&gt;' :)</span><span class="w">
</span><span class="p">{</span><span class="w"> </span><span class="nt">a</span><span class="o">:</span><span class="w"> </span><span class="s">"hello"</span><span class="w"> </span><span class="o">,</span><span class="w"> </span><span class="nt">b</span><span class="o">:</span><span class="w"> </span><span class="s">"world"</span><span class="w"> </span><span class="p">}</span><span class="o">=&gt;</span><span class="nt">b</span><span class="w"> </span><span class="c">(: yields the string "world" :)</span><span class="w">

</span><span class="c">(: the deref operator can be used to navigate into deeply nested record structures :)</span><span class="w">
</span><span class="k">let</span><span class="w"> </span><span class="nv">$n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nt">yval</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">$r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">{</span><span class="nt">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nt">m</span><span class="o">:</span><span class="s">'mvalue'</span><span class="o">,</span><span class="w"> </span><span class="nt">n</span><span class="o">:</span><span class="nv">$n</span><span class="p">}}</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">$r</span><span class="o">=&gt;</span><span class="nt">e</span><span class="o">=&gt;</span><span class="nt">n</span><span class="o">/</span><span class="nt">y</span><span class="w"> </span><span class="c">(: yields the XML fragment yval :)</span><span class="w">

</span><span class="c">(: the function bit:fields() returns the field names of a record :)</span><span class="w">
</span><span class="k">let</span><span class="w"> </span><span class="nv">$r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">{</span><span class="nt">x</span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nt">y</span><span class="o">:</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nt">z</span><span class="o">:</span><span class="w"> </span><span class="m">3</span><span class="p">}</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nf">bit:fields</span><span class="p">(</span><span class="nv">$r</span><span class="p">)</span><span class="w"> </span><span class="c">(: yields the xs:QName array [ x, y, z ] :)</span><span class="w">

</span><span class="c">(: the function bit:values() returns the field values of a record :)</span><span class="w">
</span><span class="k">let</span><span class="w"> </span><span class="nv">$r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">{</span><span class="nt">x</span><span class="o">:</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nt">y</span><span class="o">:</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nt">z</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="m">3</span><span class="o">,</span><span class="w"> </span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nf">bit:values</span><span class="p">(</span><span class="nv">$r</span><span class="p">)</span><span class="w"> </span><span class="c">(: yields the array [ 1, 2, (2,4) ] :)</span><span class="w">
</span></code></pre></div></div>

<h3 id="parsing-json">Parsing JSON</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(: the utility function json:parse() can be used to parse JSON data dynamically
   from a given xs:string
:)
let $s := io:read('/data/sample.json') return json:parse($s)
</code></pre></div></div>

<h3 id="index-structures">Index structures</h3>
<p>Index structures in Sirix are always user defined, typed indexes. We provide three types of indexes, name indexes on alement- or attribute-nodes in XML/XDM resources or name indexes on JSON object record keys, path indexes and so called content-and-structure (CAS)-indexes which are a kind of value on specific paths.</p>

<p>First, we create an element index on elements with the local name <code class="highlighter-rouge">src</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create and commit name index on all elements with QName 'src'.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">()</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStoreAndCommitStrategy</span><span class="o">(</span><span class="n">store</span><span class="o">,</span> <span class="nc">CommitStrategy</span><span class="o">.</span><span class="na">EXPLICIT</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Create name index for all elements with name 'src':"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span>
        <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1') "</span>
            <span class="o">+</span> <span class="s">"let $stats := sdb:create-name-index($doc, fn:QName((), 'src')) "</span>
            <span class="o">+</span> <span class="s">"return &lt;rev&gt;{sdb:commit($doc)}&lt;/rev&gt;"</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name index creation done."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And in order to query the name index again some time later:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query name index.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
     <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Query name index (src-element)."</span><span class="o">);</span>
 
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">queryString</span> <span class="o">=</span> <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1')"</span>
      <span class="o">+</span> <span class="s">" let $sequence := sdb:scan-name-index($doc, sdb:find-name-index($doc, fn:QName((), 'src')), fn:QName((), 'src'))"</span>
      <span class="o">+</span> <span class="s">" return sdb:sort($sequence)"</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">queryString</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">prettyPrint</span><span class="o">();</span>
  <span class="n">query</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In order to create a path index on all paths in the resource we can use:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create and commit path index on all elements.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Create path index for all elements (all paths):"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nf">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1') "</span>
          <span class="o">+</span> <span class="s">"let $stats := sdb:create-path-index($doc, '//*') "</span> <span class="o">+</span> <span class="s">"return &lt;rev&gt;{sdb:commit($doc)}&lt;/rev&gt;"</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Path index creation done."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And in order to query the path index again some time later:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query path index which are children of the log-element (only elements).</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Find path index for all elements which are children of the log-element (only elements)."</span><span class="o">);</span>
  
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">node</span> <span class="o">=</span> <span class="o">(</span><span class="nc">DBNode</span><span class="o">)</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="k">new</span> <span class="nc">SirixCompileChain</span><span class="o">(</span><span class="n">store</span><span class="o">),</span> <span class="s">"doc('mydocs.col')"</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>

  <span class="c1">// We can simply use sdb:find-path-index('xs:node', 'xs:string') to find the appropriate index number and then scan the index.</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1') "</span> <span class="o">+</span> <span class="s">"return sdb:sort(sdb:scan-path-index($doc, "</span>
      <span class="o">+</span> <span class="s">"sdb:find-path-index($doc, '//log/*'), '//log/*'))"</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">sortedSeq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">query</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">sortedIter</span> <span class="o">=</span> <span class="n">sortedSeq</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sorted index entries in document order: "</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">item</span> <span class="o">=</span> <span class="n">sortedIter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">item</span> <span class="o">=</span> <span class="n">sortedIter</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Not that in this example we showed how to get access to the low-level transactional cursor API of Sirix and use this API.</p>

<p>In order to create a CAS index for all attributes, another one for text-nodes and a third one for all integers text-nodes:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create and commit CAS indexes on all attribute- and text-nodes.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">()</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
      <span class="s">"Create a CAS index for all attributes and another one for text-nodes. A third one is created for all integers:"</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span>
      <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1') "</span>
          <span class="o">+</span> <span class="s">"let $casStats1 := sdb:create-cas-index($doc, 'xs:string', '//@*') "</span>
          <span class="o">+</span> <span class="s">"let $casStats2 := sdb:create-cas-index($doc, 'xs:string', '//*') "</span>
          <span class="o">+</span> <span class="s">"let $casStats3 := sdb:create-cas-index($doc, 'xs:integer', '//*') "</span>
          <span class="o">+</span> <span class="s">"return &lt;rev&gt;{sdb:commit($doc)}&lt;/rev&gt;"</span><span class="o">);</span>
  <span class="n">query</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"CAS index creation done."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And to find and query the CAS-index (for all attribute values) again:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query CAS index.</span>
<span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">store</span> <span class="o">=</span> <span class="nc">BasicXmlDBStore</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nc">SirixQueryContext</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">compileChain</span> <span class="o">=</span> <span class="nc">SirixCompileChain</span><span class="o">.</span><span class="na">createWithNodeStore</span><span class="o">(</span><span class="n">store</span><span class="o">))</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Find CAS index for all attribute values."</span><span class="o">);</span>
  
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">sortedSeq</span> <span class="o">=</span>
      <span class="s">"let $doc := sdb:doc('mydocs.col', 'resource1') return sdb:sort(sdb:scan-cas-index($doc, sdb:find-cas-index($doc, 'xs:string', '//@*'), 'bar', true(), true(), 0, ()))"</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">sortedSeq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XQuery</span><span class="o">(</span><span class="n">compileChain</span><span class="o">,</span> <span class="n">query</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
  <span class="kd">final</span> <span class="kt">var</span> <span class="n">sortedIter</span> <span class="o">=</span> <span class="n">sortedSeq</span><span class="o">.</span><span class="na">iterate</span><span class="o">();</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sorted index entries in document order: "</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="kt">var</span> <span class="n">item</span> <span class="o">=</span> <span class="n">sortedIter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="n">item</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">item</span> <span class="o">=</span> <span class="n">sortedIter</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In general for each index-type we have a function to create the index, to find the index-number for a given query again (the index definition must match) and to query the index.</p>
:ET