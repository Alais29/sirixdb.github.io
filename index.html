---
layout: landing-page
---		
		<!-- Main -->
			<article id="main">

				<header class="special container">
					<span class="icon fa-bar-chart-o"></span>
					<h2>SirixDB is an evolutionary, <strong>temporal</strong> NoSQL storage system at its heart, which efficiently stores the history of your data.
					<br />
					It uses <strong>copy-on-write</strong> (CoW) snapshots as well as data page versioning to store per revision and page changes.</h2>
					<p>SirixDB is especially well suited for flash drives as for instance SSDs due to its log-structure.
					<br />
					It allows <strong>time-travel</strong> queries in its binary <strong>XML</strong> as well as <strong>JSON</strong> based encodings.
                                        <br />
					It is released for free under <a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD License</a> license. Have fun!</p>
					
					<p>The following XQuery for JSON query opens a database and therein a resource in a specific revision based 
					<br />
				        on a timestamp and searches for a status, which didn't exist in the previous revision.</p>
					<p>&nbsp;</p>
					
				<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let $statuses := jn:open('mycol.jn','mydoc.jn', xs:dateTime('2019-04-13T16:24:27Z'))=>statuses
let $foundStatus := for $status in bit:array-values($statuses)
  let $dateTimeCreated := xs:dateTime($status=>created_at)
  where $dateTimeCreated > xs:dateTime("2018-02-01T00:00:00") and not(exists(jn:previous($status)))
  order by $dateTimeCreated
  return $status
return {"revision": sdb:revision($foundStatus), $foundStatus{text}}
</code></pre></div></div>
					
					<p>&nbsp;</p>
				</header>
					
				<!-- One -->
					<section class="wrapper style2 container special-alt">
						<div class="row half">
							<div class="8u">
							
								<header>
									<h2>Keep the full history of your data for time travel analysis, audits, to correct human or application errors...</h2>
								</header>
								<p>SirixDB takes care of keeping storage space to a minimum while supporting the reconstruction of any revision in linear time.</p>
								<p>Furthermore, it allows time travel queries such that you're able to analyze the history of your data efficiently to predict the future or for audits.</p>
                                                                <p>Not enough? What about correcting any human or application errors or to compare any revision of your XML or JSON documents efficiently?</p>
                                                                <footer>
									<ul class="buttons">
										<li><a href="#more" class="button fit scrolly">Find Out More</a></li>
									</ul>
								</footer>
							
							</div>
							<div class="4u skel-cell-important">
							
								<ul class="featured-icons">
									<li><span class="icon fa-clock-o"><span class="label">Time Travel</span></span></li>
									<li><span class="icon fa-rocket"><span class="label">Fast</span></span></li>
									<li><span class="icon fa-laptop"><span class="label">JVM-based (available on any platform)</span></span></li>
									<li><span class="icon fa-database"><span class="label">Versioned, temporal database system</span></span></li>
									<li><span class="icon fa-github"><span class="label">Open Source and free on Github</span></span></li>
									<li><span class="icon fa-cloud"><span class="label">Replication/Partitioning soon to be added</span></span></li>
								</ul>
							
							</div>				
						</div>
					</section>
					
				<!-- Two -->
					<section class="wrapper style1 container special" id="more">
						<div class="row">
							<div class="4u">
							
								<section>
									<span class="icon featured fa-check"></span>
									<header>
										<h3>Versioning</h3>
									</header>
									<p>SirixDB versions data as well as index-structures on a per revision and record level. As such versioning takes place at a fine-granular level. Furthermore, through a novel versioning algorithm called <em>sliding snapshot</em>, it can avoid write and read peaks.</p>
								</section>
							
							</div>
							<div class="4u">
							
								<section>
									<span class="icon featured fa-check"></span>
									<header>
										<h3>Time travel queries</h3>
									</header>
									<p>SirixDB allows sophisticated time travel queries, such that you can analyze the history of your data or to retrieve the differences efficiently.</p>
								</section>
							
							</div>
							<div class="4u">
							
								<section>
									<span class="icon featured fa-check"></span>
									<header>
										<h3>XML / JSON</h3>
									</header>
									<p>You decide how your data looks like and which format fits best. SirixDB currently supports both the import of XML as well as JSON data.</p>
								</section>
							
							</div>
						</div>
					</section>
					
				<!-- Three -->
					<section class="wrapper style3 container special">
					
						<header class="major">
							<h2>Powerful APIs</h2>
						</header>
						
						<div class="row">
							<div class="6u">
							
								<section>
									<a href="/rest-api.html" class="image featured"><img src="images/shutterstock_552791071-scaled.jpg" alt="" /></a>
									<header>
										<h3>REST</h3>
									</header>
									<p>SirixDB provides an asynchronous, RESTful API, which is non-blocking. It is built with <a href="https://vertx.io">Vert.x</a>, <a href="https://kotlinlang.org">Kotlin</a> (coroutines) and <a href="https://www.keycloak.org">Keycloak</a>.</p>
								</section>

							</div>
							<div class="6u">
							
								<section>
									<a href="/xquery-api.html" class="image featured"><img src="images/shutterstock_667831573-scaled.jpg" alt="" /></a>
									<header>
										<h3>XQuery / JSONiq</h3>
									</header>
									<p>Several extensions to an XQuery-processor called <a href="http://brackit.org">Brackit</a> are available. SirixDB, for instance, supports navigation via additional temporal XPath axes or XQuery functions for JSON data to navigate not only in space but also in time. Furthermore, SirixDB offers several additional precompiled functions to simplify the analysis of your temporal data. The API also provides a very convenient way to interact with SirixDB. Think of it as an in-memory representation of a DOM.</p>
								</section>
								
							</div>
						</div>
						<div class="row">
							<div class="6u">
							
								<section>
									<a href="/transactional-cursor-api.html" class="image featured"><img src="images/shutterstock_534465157-scaled.jpg" alt="" /></a>
									<header>
										<h3>Transactional cursor API</h3>
									</header>
									<p>SirixDB provides a transactional low level, cursor-based API which is very powerful. SirixDB not only provides standard XPath axes. It also provides additionally temporal enhancements to navigate in time. Furthermore several other axes, for instance, a LevelOrder axis, a PostorderAxis and a DescendantAxis which can skip whole subtrees exists. Additionally, SirixDB provides several filters, a NestedAxis, a PredicateAxis and much more.</p>
								</section>

							</div>
							<div class="6u">
							
								<section>
									<a href="#" class="image featured"><img src="images/shutterstock_709259401-scaled.jpg" alt="" /></a>
									<header>
										<h3>Diffing-API</h3>
									</header>
									<p>SirixDB provides a way to currently import several revisions of an XML document with the help of a diffing-algorithm called Fast Matching Simple EditScript. With the help of this diffing-algorithm SirixDB can store the encountered differences in the tree structures instead of storing the whole revision.</p>
<p>Once you've stored several revisions in SirixDB, either through the import based on the diffing-algorithm or simply through working with SirixDB in the first place you're able to quickly compute diffs between any two revisions. SirixDB makes use of its stable node identifiers and optionally stored hashes. Each time the hashes of two nodes are equal, the whole subtrees in both revisions can be skipped while traversing both tree structures.</p>
								</section>

							</div>
						</div>

						<footer class="major">
							<ul class="buttons">
								<li><a href="/documentation.html" class="button">See More</a></li>
							</ul>
						</footer>
					
					</section>
					
			</article>

		<!-- CTA -->
			<section id="cta">
			
				<header>
					<h2>Ready for using <strong>SirixDB</strong>?</h2>
					<p>Give it a try and let us know what you think.</p>
				</header>
				<footer>
					<ul class="buttons">
						<li><a href="/documentation.html" class="button special">First steps</a></li>
						<li><a href="https://github.com/sirixdb/sirix" class="button">Fork me on Github</a></li>
					</ul>
				</footer>
			
			</section>
